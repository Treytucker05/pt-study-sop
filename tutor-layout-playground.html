<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Arcade Page Builder</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  :root {
    --primary: #ef4444;
    --primary-dim: rgba(239,68,68,0.3);
    --primary-bg: rgba(239,68,68,0.08);
    --bg: #0a0a0a;
    --surface: rgba(0,0,0,0.7);
    --surface-light: rgba(20,20,20,0.9);
    --border: rgba(239,68,68,0.4);
    --text: #e5e5e5;
    --muted: #737373;
    --yellow: #eab308;
    --blue: #60a5fa;
    --green: #4ade80;
    --purple: #a78bfa;
    --cyan: #22d3ee;
    --font-arcade: 'Courier New', monospace;
    --font-terminal: 'Consolas', 'Courier New', monospace;
    --grid: 8px;
  }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: var(--font-terminal);
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  /* â•â•â• TOP TOOLBAR â•â•â• */
  .toolbar {
    height: 40px;
    background: #111;
    border-bottom: 2px solid var(--primary);
    display: flex;
    align-items: center;
    padding: 0 10px;
    gap: 4px;
    flex-shrink: 0;
    z-index: 1000;
    overflow-x: auto;
    overflow-y: hidden;
  }
  .toolbar::-webkit-scrollbar { height: 2px; }
  .toolbar::-webkit-scrollbar-thumb { background: var(--primary-dim); }

  .tb-group {
    display: flex;
    align-items: center;
    gap: 2px;
    flex-shrink: 0;
  }
  .toolbar h1 {
    font-family: var(--font-arcade);
    font-size: 12px;
    color: var(--primary);
    letter-spacing: 2px;
    white-space: nowrap;
  }
  .sep { width: 1px; height: 18px; background: var(--primary-dim); flex-shrink: 0; }

  .tb-btn {
    background: transparent;
    border: 1px solid var(--primary-dim);
    color: var(--text);
    font-family: var(--font-arcade);
    font-size: 10px;
    padding: 3px 8px;
    cursor: pointer;
    letter-spacing: 1px;
    transition: all 0.15s;
    white-space: nowrap;
  }
  .tb-btn:hover { background: var(--primary-bg); border-color: var(--primary); color: var(--primary); }
  .tb-btn.active { background: var(--primary); color: #000; border-color: var(--primary); }
  .tb-btn.danger { border-color: rgba(239,68,68,0.5); }
  .tb-btn.danger:hover { background: rgba(239,68,68,0.2); color: #ef4444; }

  .tb-copy {
    margin-left: auto;
    background: var(--primary);
    color: #000;
    border: none;
    font-family: var(--font-arcade);
    font-size: 10px;
    padding: 5px 14px;
    cursor: pointer;
    letter-spacing: 1px;
    font-weight: bold;
  }
  .tb-copy:hover { filter: brightness(1.2); }

  /* â•â•â• MAIN LAYOUT â•â•â• */
  .main {
    flex: 1;
    display: flex;
    min-height: 0;
  }

  /* â•â•â• PALETTE SIDEBAR â•â•â• */
  .palette {
    width: 220px;
    background: #0d0d0d;
    border-right: 2px solid var(--primary-dim);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    flex-shrink: 0;
    z-index: 50;
  }
  .palette-header {
    padding: 8px 10px;
    font-family: var(--font-arcade);
    font-size: 10px;
    color: var(--primary);
    letter-spacing: 2px;
    border-bottom: 1px solid var(--primary-dim);
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .palette-scroll {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
  }
  .palette-scroll::-webkit-scrollbar { width: 4px; }
  .palette-scroll::-webkit-scrollbar-thumb { background: var(--primary-dim); }

  .pal-section {
    border-bottom: 1px solid rgba(239,68,68,0.1);
  }
  .pal-section-header {
    padding: 6px 10px;
    font-family: var(--font-arcade);
    font-size: 9px;
    color: var(--muted);
    letter-spacing: 2px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: space-between;
    user-select: none;
  }
  .pal-section-header:hover { color: var(--primary); background: rgba(239,68,68,0.03); }
  .pal-section-header .arrow { font-size: 8px; transition: transform 0.15s; }
  .pal-section-header .arrow.open { transform: rotate(90deg); }
  .pal-section-body { padding: 4px 8px 8px; display: flex; flex-direction: column; gap: 4px; }
  .pal-section-body.closed { display: none; }

  .pal-item {
    padding: 6px 8px;
    background: rgba(0,0,0,0.4);
    border: 1px solid rgba(255,255,255,0.06);
    cursor: grab;
    font-size: 11px;
    display: flex;
    align-items: center;
    gap: 6px;
    transition: all 0.12s;
    user-select: none;
  }
  .pal-item:hover {
    border-color: var(--primary-dim);
    background: rgba(239,68,68,0.05);
  }
  .pal-item:active { cursor: grabbing; opacity: 0.7; }
  .pal-item .icon { font-size: 13px; width: 18px; text-align: center; flex-shrink: 0; }
  .pal-item .label { font-family: var(--font-terminal); font-size: 10px; color: var(--text); }
  .pal-item .hint { font-family: var(--font-terminal); font-size: 9px; color: var(--muted); margin-left: auto; }

  /* â•â•â• CANVAS â•â•â• */
  .canvas {
    flex: 1;
    position: relative;
    overflow: hidden;
    border-right: 2px solid var(--primary-dim);
    background:
      radial-gradient(circle at 50% 50%, rgba(239,68,68,0.02) 0%, transparent 70%),
      repeating-linear-gradient(0deg, transparent, transparent calc(var(--grid) - 1px), rgba(239,68,68,0.03) var(--grid)),
      repeating-linear-gradient(90deg, transparent, transparent calc(var(--grid) - 1px), rgba(239,68,68,0.03) var(--grid));
  }
  .canvas.drop-active {
    background-color: rgba(239,68,68,0.02);
  }

  /* â•â•â• PANEL â•â•â• */
  .panel {
    position: absolute;
    background: var(--surface);
    border: 2px solid var(--primary);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    min-width: 120px;
    min-height: 48px;
  }
  .panel.dragging { box-shadow: 0 0 20px rgba(239,68,68,0.25); z-index: 100; }
  .panel.selected { box-shadow: 0 0 0 2px rgba(239,68,68,0.5), 0 0 16px rgba(239,68,68,0.15); z-index: 99; }
  .panel.drop-target { border-color: var(--green); box-shadow: 0 0 12px rgba(74,222,128,0.3); }

  .panel-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 3px 8px;
    background: rgba(239,68,68,0.1);
    border-bottom: 1px solid var(--primary-dim);
    cursor: move;
    user-select: none;
    min-height: 24px;
    gap: 6px;
  }
  .panel-header .title {
    font-family: var(--font-arcade);
    font-size: 10px;
    color: var(--primary);
    letter-spacing: 2px;
  }
  .panel-header .dims {
    font-size: 9px;
    color: var(--muted);
    font-family: var(--font-terminal);
  }
  .panel-header .close-btn {
    width: 14px; height: 14px;
    display: flex; align-items: center; justify-content: center;
    font-size: 10px; color: var(--muted);
    cursor: pointer; border: none; background: none;
    opacity: 0; transition: opacity 0.15s;
  }
  .panel-header:hover .close-btn { opacity: 1; }
  .panel-header .close-btn:hover { color: var(--primary); }

  .panel-body {
    flex: 1;
    overflow: auto;
    position: relative;
    display: flex;
    flex-direction: column;
  }

  /* zone resize dividers (between inner boxes) */
  .zone-divider {
    height: 6px;
    cursor: row-resize;
    background: transparent;
    position: relative;
    flex-shrink: 0;
    z-index: 5;
    user-select: none;
  }
  .zone-divider::after {
    content: '';
    position: absolute;
    left: 25%;
    right: 25%;
    top: 2px;
    height: 2px;
    background: var(--primary-dim);
    border-radius: 1px;
    transition: background 0.15s;
  }
  .zone-divider:hover::after,
  .zone-divider.active::after {
    background: var(--primary);
    left: 10%;
    right: 10%;
  }

  /* column resize dividers (between side-by-side zones) */
  .zone-col-divider {
    width: 6px;
    cursor: col-resize;
    background: transparent;
    position: relative;
    flex-shrink: 0;
    z-index: 5;
    user-select: none;
  }
  .zone-col-divider::after {
    content: '';
    position: absolute;
    top: 25%;
    bottom: 25%;
    left: 2px;
    width: 2px;
    background: var(--primary-dim);
    border-radius: 1px;
    transition: background 0.15s;
  }
  .zone-col-divider:hover::after,
  .zone-col-divider.active::after {
    background: var(--primary);
    top: 10%;
    bottom: 10%;
  }

  /* row container for side-by-side zones */
  .zone-row {
    display: flex;
    flex-direction: row;
    flex: 1;
    min-height: 0;
    overflow: hidden;
  }

  /* nested inner box */
  .inner-box {
    border: 2px solid var(--primary-dim);
    background: rgba(0,0,0,0.15);
    min-height: 48px;
    min-width: 80px;
    padding: 6px;
    display: flex;
    flex-direction: column;
    gap: 4px;
    position: relative;
    flex-shrink: 0;
    position: relative;
  }
  .inner-box.drop-zone.highlight {
    border-color: var(--green);
    background: rgba(74,222,128,0.08);
  }
  .inner-box .box-label {
    font-family: var(--font-arcade);
    font-size: 8px;
    color: var(--muted);
    letter-spacing: 1px;
    user-select: none;
    pointer-events: none;
    position: absolute;
    top: 1px; right: 4px;
    opacity: 0.4;
  }

  /* border toggle */
  body.hide-borders .inner-box { border-color: transparent !important; }
  body.hide-borders .drop-zone { border-color: transparent !important; }
  body.hide-borders .c-divider,
  body.hide-borders .c-divider-thick { background: transparent !important; }
  body.hide-borders .zone-divider::after,
  body.hide-borders .zone-col-divider::after { background: transparent !important; }

  /* hand tool cursor */
  .canvas.hand-mode { cursor: grab; }
  .canvas.hand-mode .panel,
  .canvas.hand-mode .drop-zone,
  .canvas.hand-mode .inner-box,
  .canvas.hand-mode .drag-item { cursor: grab; }
  .canvas.hand-mode .panel.dragging,
  .canvas.hand-mode .drop-zone.hand-dragging { cursor: grabbing; }

  /* hand-selected element highlight */
  .hand-target {
    outline: 2px dashed var(--cyan) !important;
    outline-offset: -1px;
  }

  /* locked-on element selection */
  .element-selected {
    outline: 3px solid var(--cyan) !important;
    outline-offset: 2px;
    box-shadow: 0 0 12px rgba(34,211,238,0.5), inset 0 0 8px rgba(34,211,238,0.1) !important;
  }
  .element-grouped {
    outline: 2px solid var(--cyan) !important;
    outline-offset: 1px;
    box-shadow: 0 0 8px rgba(34,211,238,0.3) !important;
  }

  /* resize handles â€” pointer-events only active when panel is selected */
  .rh { position: absolute; z-index: 10; pointer-events: none; }
  .panel.selected > .rh { pointer-events: auto; }
  .rh.n  { top:-3px; left:6px; right:6px; height:6px; cursor:n-resize; }
  .rh.s  { bottom:-3px; left:6px; right:6px; height:6px; cursor:s-resize; }
  .rh.e  { right:-3px; top:6px; bottom:6px; width:6px; cursor:e-resize; }
  .rh.w  { left:-3px; top:6px; bottom:6px; width:6px; cursor:w-resize; }
  .rh.ne { top:-3px; right:-3px; width:10px; height:10px; cursor:ne-resize; }
  .rh.nw { top:-3px; left:-3px; width:10px; height:10px; cursor:nw-resize; }
  .rh.se { bottom:-3px; right:-3px; width:10px; height:10px; cursor:se-resize; }
  .rh.sw { bottom:-3px; left:-3px; width:10px; height:10px; cursor:sw-resize; }

  /* â•â•â• DROP ZONE inside panels â•â•â• */
  .drop-zone {
    min-height: 16px;
    border: 1px dashed transparent;
    transition: border-color 0.12s, background 0.12s;
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    align-items: center;
    padding: 3px 6px;
  }
  .drop-zone.highlight { border-color: var(--green); background: rgba(74,222,128,0.05); }
  .drop-zone.vertical { flex-direction: column; align-items: stretch; flex: 1; min-height: 0; overflow-y: auto; }
  .drop-zone.horizontal-fill { flex: 1; justify-content: space-between; }

  /* â•â•â• DRAGGABLE ITEMS â•â•â• */
  .drag-item {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    cursor: grab;
    user-select: none;
    transition: outline 0.1s;
    position: relative;
  }
  .drag-item:active { cursor: grabbing; }
  .drag-item.dragging-item { opacity: 0.5; outline: 1px dashed var(--primary); }

  /* Item resize handle â€” visible only when selected */
  .item-rh {
    position: absolute;
    width: 10px;
    height: 10px;
    background: var(--cyan);
    z-index: 5;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.1s;
  }
  .item-rh.se { bottom: -3px; right: -3px; cursor: se-resize; }
  .item-rh.e  { top: 50%; right: -3px; transform: translateY(-50%); width: 6px; height: 14px; cursor: e-resize; }
  .item-rh.s  { bottom: -3px; left: 50%; transform: translateX(-50%); width: 14px; height: 6px; cursor: s-resize; }
  .element-selected > .item-rh,
  .element-grouped > .item-rh { opacity: 1; pointer-events: auto; }

  /* â•â•â• COMPONENT STYLES â•â•â• */

  /* Buttons */
  .c-btn-primary {
    padding: 4px 14px;
    font-family: var(--font-arcade);
    font-size: 10px;
    letter-spacing: 1px;
    background: var(--primary);
    border: 2px solid var(--primary);
    color: #000;
    font-weight: bold;
    white-space: nowrap;
  }
  .c-btn-ghost {
    padding: 4px 12px;
    font-family: var(--font-terminal);
    font-size: 11px;
    background: transparent;
    border: 1px solid var(--primary-dim);
    color: var(--text);
    white-space: nowrap;
  }
  .c-btn-outline {
    padding: 4px 12px;
    font-family: var(--font-arcade);
    font-size: 10px;
    letter-spacing: 1px;
    background: transparent;
    border: 2px solid var(--primary);
    color: var(--primary);
    white-space: nowrap;
  }
  .c-btn-icon {
    width: 28px; height: 28px;
    display: inline-flex; align-items: center; justify-content: center;
    background: transparent;
    border: 1px solid var(--primary-dim);
    color: var(--muted);
    font-size: 13px;
  }

  /* Inputs */
  .c-input {
    padding: 4px 10px;
    font-family: var(--font-terminal);
    font-size: 11px;
    background: rgba(0,0,0,0.5);
    border: 1px solid var(--primary-dim);
    color: var(--muted);
    white-space: nowrap;
    min-width: 100px;
  }
  .c-input-search {
    padding: 4px 10px 4px 24px;
    font-family: var(--font-terminal);
    font-size: 11px;
    background: rgba(0,0,0,0.5);
    border: 1px solid var(--primary-dim);
    color: var(--muted);
    white-space: nowrap;
    position: relative;
    min-width: 120px;
  }
  .c-select {
    padding: 4px 10px;
    font-family: var(--font-terminal);
    font-size: 11px;
    background: rgba(0,0,0,0.5);
    border: 1px solid var(--primary-dim);
    color: var(--text);
    white-space: nowrap;
  }
  .c-textarea {
    padding: 6px 10px;
    font-family: var(--font-terminal);
    font-size: 11px;
    background: rgba(0,0,0,0.4);
    border: 1px solid var(--primary-dim);
    color: var(--muted);
    min-height: 60px;
    width: 100%;
    white-space: pre-wrap;
  }

  /* Chips & Badges */
  .c-chip {
    padding: 3px 10px;
    font-family: var(--font-arcade);
    font-size: 9px;
    letter-spacing: 1px;
    border: 2px solid var(--primary-dim);
    background: rgba(0,0,0,0.5);
    color: rgba(239,68,68,0.8);
    white-space: nowrap;
  }
  .c-chip.on { background: var(--primary); color: #000; border-color: var(--primary); }
  .c-badge {
    padding: 1px 6px;
    font-family: var(--font-arcade);
    font-size: 9px;
    letter-spacing: 1px;
    border: 1px solid var(--primary-dim);
    color: var(--primary);
    white-space: nowrap;
  }
  .c-badge.green { border-color: rgba(74,222,128,0.5); color: var(--green); }
  .c-badge.blue { border-color: rgba(96,165,250,0.5); color: var(--blue); }

  /* Toggle */
  .c-toggle-group { display: inline-flex; gap: 0; }
  .c-toggle-btn {
    padding: 3px 10px;
    font-family: var(--font-terminal);
    font-size: 10px;
    border: 1px solid var(--primary-dim);
    background: rgba(0,0,0,0.5);
    color: var(--muted);
    white-space: nowrap;
  }
  .c-toggle-btn.on { background: var(--primary-bg); color: var(--primary); border-color: var(--primary); }

  /* Checkbox */
  .c-check {
    display: inline-flex; align-items: center; gap: 5px;
    font-family: var(--font-terminal); font-size: 11px; color: var(--muted); white-space: nowrap;
  }
  .c-check .box {
    width: 13px; height: 13px;
    border: 1px solid var(--primary-dim);
    background: rgba(0,0,0,0.4);
    display: inline-flex; align-items: center; justify-content: center;
  }

  /* Labels & Text */
  .c-label {
    font-family: var(--font-arcade);
    font-size: 10px;
    color: var(--primary);
    letter-spacing: 2px;
    white-space: nowrap;
  }
  .c-label-muted {
    font-family: var(--font-arcade);
    font-size: 9px;
    color: var(--muted);
    letter-spacing: 1px;
    white-space: nowrap;
  }
  .c-text {
    font-family: var(--font-terminal);
    font-size: 11px;
    color: var(--text);
    white-space: nowrap;
  }
  .c-text-muted {
    font-family: var(--font-terminal);
    font-size: 11px;
    color: var(--muted);
    white-space: nowrap;
  }

  /* Dividers */
  .c-divider {
    height: 1px;
    background: var(--primary-dim);
    width: 100%;
    flex-shrink: 0;
  }
  .c-divider-thick {
    height: 2px;
    background: var(--primary);
    width: 100%;
    flex-shrink: 0;
  }

  /* Icons with text */
  .c-icon-text {
    display: inline-flex; align-items: center; gap: 4px;
    font-family: var(--font-terminal); font-size: 11px; color: var(--muted);
    white-space: nowrap;
  }

  /* Tree items */
  .c-tree-folder {
    display: flex; align-items: center; gap: 4px;
    padding: 2px 0;
    font-family: var(--font-terminal); font-size: 11px; white-space: nowrap; width: 100%;
  }
  .c-tree-file {
    display: flex; align-items: center; gap: 4px;
    padding: 2px 0 2px 14px;
    font-family: var(--font-terminal); font-size: 11px; white-space: nowrap; width: 100%;
  }
  .c-tree-folder .box, .c-tree-file .box {
    width: 11px; height: 11px;
    border: 1px solid var(--primary-dim);
    background: rgba(0,0,0,0.4);
    flex-shrink: 0;
  }

  /* Session chip */
  .c-session {
    display: inline-flex; align-items: center; gap: 4px;
    padding: 3px 8px;
    border: 1px solid rgba(255,255,255,0.1);
    font-family: var(--font-terminal); font-size: 10px; color: var(--muted);
    white-space: nowrap;
  }
  .c-session .dot {
    width: 5px; height: 5px; border-radius: 50%;
  }
  .c-session .dot.green { background: var(--green); }
  .c-session .dot.gray { background: var(--muted); }

  /* Stat block */
  .c-stat {
    display: inline-flex; flex-direction: column; align-items: center; gap: 2px;
    padding: 6px 12px;
    border: 1px solid var(--primary-dim);
    background: rgba(0,0,0,0.3);
    min-width: 60px;
  }
  .c-stat .val { font-family: var(--font-arcade); font-size: 16px; color: var(--primary); }
  .c-stat .lbl { font-family: var(--font-terminal); font-size: 9px; color: var(--muted); letter-spacing: 1px; }

  /* Progress bar */
  .c-progress {
    height: 6px;
    background: rgba(0,0,0,0.4);
    border: 1px solid var(--primary-dim);
    width: 100%;
    position: relative;
  }
  .c-progress .fill {
    position: absolute;
    left: 0; top: 0; bottom: 0;
    background: var(--primary);
    width: 65%;
  }

  /* Chat bubble */
  .c-chat-user {
    padding: 6px 10px;
    background: rgba(239,68,68,0.1);
    border: 1px solid var(--primary-dim);
    font-family: var(--font-terminal); font-size: 11px; color: var(--text);
    max-width: 80%;
    align-self: flex-end;
  }
  .c-chat-ai {
    padding: 6px 10px;
    background: rgba(0,0,0,0.4);
    border: 1px solid rgba(255,255,255,0.08);
    font-family: var(--font-terminal); font-size: 11px; color: var(--text);
    max-width: 80%;
    align-self: flex-start;
  }

  /* Scroll area indicator */
  .c-scroll-area {
    border: 1px solid var(--primary-dim);
    background: rgba(0,0,0,0.2);
    padding: 4px;
    min-height: 40px;
    width: 100%;
    position: relative;
    display: flex;
    flex-direction: column;
    gap: 2px;
  }
  .c-scroll-area::after {
    content: 'â†• scroll';
    position: absolute;
    right: 4px;
    top: 4px;
    font-size: 8px;
    color: var(--muted);
    opacity: 0.5;
  }

  /* â•â•â• GHOST (drag preview) â•â•â• */
  .drag-ghost {
    position: fixed;
    pointer-events: none;
    z-index: 10000;
    opacity: 0.8;
    transform: scale(1.02);
    filter: drop-shadow(0 0 8px rgba(239,68,68,0.4));
  }

  /* â•â•â• INFO BAR â•â•â• */
  .info-bar {
    height: 32px;
    background: #111;
    border-top: 1px solid var(--primary-dim);
    display: flex;
    align-items: center;
    padding: 0 12px;
    gap: 16px;
    font-size: 10px;
    color: var(--muted);
    flex-shrink: 0;
    z-index: 1000;
  }
  .info-bar .val { color: var(--primary); font-weight: bold; }

  /* â•â•â• PROMPT BAR â•â•â• */
  .prompt-bar {
    background: #111;
    border-top: 1px solid var(--primary-dim);
    padding: 6px 12px;
    display: none;
    font-size: 10px;
    color: var(--text);
    gap: 8px;
    align-items: flex-start;
    flex-shrink: 0;
    max-height: 140px;
  }
  .prompt-bar.visible { display: flex; }
  .prompt-bar pre {
    flex: 1;
    white-space: pre-wrap;
    font-family: var(--font-terminal);
    font-size: 10px;
    max-height: 120px;
    overflow-y: auto;
  }
  .prompt-bar button {
    background: var(--primary-dim);
    border: none;
    color: var(--text);
    font-size: 9px;
    padding: 2px 8px;
    cursor: pointer;
    font-family: var(--font-arcade);
  }
</style>
</head>
<body>

<!-- â•â•â• TOOLBAR â•â•â• -->
<div class="toolbar">
  <h1>PAGE BUILDER</h1>
  <div class="sep"></div>
  <button class="tb-btn" onclick="loadPage('tutor-setup')">TUTOR SETUP</button>
  <button class="tb-btn" onclick="loadPage('tutor-chat')">TUTOR CHAT</button>
  <button class="tb-btn" onclick="loadPage('empty')">BLANK</button>
  <div class="sep"></div>
  <button class="tb-btn" onclick="toggleSnap()" id="snapBtn">SNAP: ON</button>
  <button class="tb-btn active" onclick="togglePush()" id="pushBtn">PUSH: ON</button>
  <button class="tb-btn" onclick="toggleHand()" id="handBtn">âœ‹ HAND</button>
  <div class="sep"></div>
  <button class="tb-btn" onclick="addHSplit()">H-SPLIT</button>
  <button class="tb-btn" onclick="addVSplit()">V-SPLIT</button>
  <button class="tb-btn" onclick="addBox()">+BOX</button>
  <button class="tb-btn" onclick="toggleBorders()" id="borderBtn">BORDERS: ON</button>
  <div class="sep"></div>
  <button class="tb-btn" onclick="splitPanel('2-col')">2-COL</button>
  <button class="tb-btn" onclick="splitPanel('3-col')">3-COL</button>
  <button class="tb-btn" onclick="splitPanel('2-row')">2-ROW</button>
  <button class="tb-btn" onclick="splitPanel('grid')">GRID</button>
  <div class="sep"></div>
  <div class="tb-group">
    <button class="tb-btn" onclick="alignPanels('left')" title="Align left">â—€</button>
    <button class="tb-btn" onclick="alignPanels('center')" title="Center">â—†</button>
    <button class="tb-btn" onclick="alignPanels('right')" title="Align right">â–¶</button>
  </div>
  <div class="sep"></div>
  <button class="tb-btn" onclick="autoSpace()" title="Even vertical spacing">SPACE</button>
  <div class="tb-group">
    <button class="tb-btn" onclick="adjustGap(-8)" title="Decrease gap">âˆ’</button>
    <button class="tb-btn" onclick="adjustGap(8)" title="Increase gap">+</button>
  </div>
  <div class="sep"></div>
  <button class="tb-btn" onclick="undo()" title="Undo (Ctrl+Z)">UNDO</button>
  <button class="tb-btn" onclick="detachElement()" title="Break selected element out of its container">DETACH</button>
  <button class="tb-btn" onclick="explodePanel()">EXPLODE</button>
  <button class="tb-btn danger" onclick="deleteSelected()">DELETE</button>
  <button class="tb-copy" onclick="copyPrompt()">COPY LAYOUT</button>
</div>

<!-- â•â•â• MAIN â•â•â• -->
<div class="main">
  <!-- Palette -->
  <div class="palette" id="palette">
    <div class="palette-header">
      <span>COMPONENTS</span>
      <span style="font-size:9px;color:var(--muted)">drag â†’</span>
    </div>
    <div class="palette-scroll" id="paletteScroll"></div>
  </div>

  <!-- Canvas -->
  <div class="canvas" id="canvas"></div>
</div>

<!-- â•â•â• INFO BAR â•â•â• -->
<div class="info-bar">
  <span>Canvas: <span class="val" id="infoCanvas">--</span></span>
  <span>Selected: <span class="val" id="infoSelected">none</span></span>
  <span>Pos: <span class="val" id="infoPos">--</span></span>
  <span>Size: <span class="val" id="infoSize">--</span></span>
  <span style="margin-left:auto;color:var(--muted)">Drag from palette to add â€¢ headers to move â€¢ edges to resize â€¢ items to reorder</span>
</div>
<div class="info-bar" style="border-top:1px solid var(--primary-dim);font-size:10px;color:var(--cyan)">
  <span>DEBUG Click: <span class="val" id="debugTarget">--</span></span>
  <span>Action: <span class="val" id="debugAction">--</span></span>
  <span>Pointer-events: <span class="val" id="debugPE">--</span></span>
</div>

<!-- â•â•â• PROMPT BAR â•â•â• -->
<div class="prompt-bar" id="promptBar">
  <pre id="promptText"></pre>
  <button onclick="document.getElementById('promptBar').classList.remove('visible')">CLOSE</button>
</div>

<!-- â•â•â• GHOST (for palette drag) â•â•â• -->
<div class="drag-ghost" id="dragGhost" style="display:none"></div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let snap = true;
const SNAP_SZ = 8;
let panels = {};
let panelCounter = 0;
let selectedPanelId = null;

let dragState = null;     // panel move/resize
let itemDragState = null; // item reorder
let paletteDrag = null;   // dragging from palette
let pushEnabled = true;   // push siblings on overlap
let zoneDragState = null; // inner zone resize
let bordersVisible = true;
let handMode = false;
let handDragState = null; // hand tool drag
let selectedElement = null; // locked-on inner element
let groupedElements = new Set(); // shift-click multi-select group
let itemResizeState = null; // inner item resize drag

// Undo history
const undoStack = [];
const MAX_UNDO = 50;

const canvas = document.getElementById('canvas');
const ghost = document.getElementById('dragGhost');

// Safety: reset any stuck pointer-events/opacity from incomplete drags
function cleanupStuckDragStyles() {
  // Reset stuck pointer-events on canvas elements
  canvas.querySelectorAll('.drag-item, .inner-box').forEach(el => {
    if (el.style.pointerEvents === 'none') el.style.pointerEvents = '';
    if (el.style.opacity && el.style.opacity !== '1') el.style.opacity = '';
  });
  // Clean floated elements stuck on document.body
  document.querySelectorAll('body > .drag-item, body > .inner-box').forEach(el => {
    el.style.position = '';
    el.style.left = '';
    el.style.top = '';
    el.style.width = '';
    el.style.zIndex = '';
    el.style.boxShadow = '';
    el.style.opacity = '';
    el.style.pointerEvents = '';
  });
  canvas.querySelectorAll('.dragging-item').forEach(el => el.classList.remove('dragging-item'));
  canvas.querySelectorAll('.hand-target').forEach(el => el.classList.remove('hand-target'));
}

// If user tabs away mid-drag, clean up all drag state
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    if (handDragState || itemDragState || dragState || zoneDragState) {
      cleanupStuckDragStyles();
      handDragState = null;
      itemDragState = null;
      dragState = null;
      zoneDragState = null;
      itemResizeState = null;
      document.querySelectorAll('.panel.dragging').forEach(p => p.classList.remove('dragging'));
      document.querySelectorAll('.drop-zone.highlight').forEach(z => z.classList.remove('highlight'));
    }
  }
});

function snapV(v) { return snap ? Math.round(v / SNAP_SZ) * SNAP_SZ : v; }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SHARED: insert element at cursor position in a zone
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function insertAtCursor(el, zone, e) {
  const siblings = [...zone.children].filter(c => c !== el);
  const style = window.getComputedStyle(zone);
  const isVert = style.flexDirection === 'column';
  let inserted = false;
  for (const sib of siblings) {
    if (sib.classList.contains('zone-divider') || sib.classList.contains('zone-col-divider') || sib.classList.contains('box-label')) continue;
    const rect = sib.getBoundingClientRect();
    const mid = isVert ? rect.top + rect.height / 2 : rect.left + rect.width / 2;
    const pos = isVert ? e.clientY : e.clientX;
    if (pos < mid) { zone.insertBefore(el, sib); inserted = true; break; }
  }
  if (!inserted) zone.appendChild(el);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CLOSE GAPS â€” slide panels up when space opens below resize
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function closeGaps() {
  if (!pushEnabled) return;
  const ids = Object.keys(panels);
  if (ids.length < 2) return;

  const sorted = [...ids].sort((a, b) =>
    (parseInt(panels[a].el.style.top) || 0) - (parseInt(panels[b].el.style.top) || 0)
  );

  for (let i = 1; i < sorted.length; i++) {
    const above = panels[sorted[i - 1]].el;
    const below = panels[sorted[i]].el;
    const aboveBottom = (parseInt(above.style.top) || 0) + (parseInt(above.style.height) || 48);
    const belowTop = parseInt(below.style.top) || 0;

    // Only close if panels overlap horizontally
    const aL = parseInt(above.style.left) || 0, aR = aL + (parseInt(above.style.width) || 120);
    const bL = parseInt(below.style.left) || 0, bR = bL + (parseInt(below.style.width) || 120);
    if (aR > bL && bR > aL) {
      const gap = belowTop - aboveBottom;
      if (gap > PUSH_GAP) {
        below.style.top = snapV(aboveBottom + PUSH_GAP) + 'px';
        updateDims(sorted[i]);
      }
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COLLISION DETECTION â€” push siblings out of the way
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const PUSH_GAP = 8;

function getPanelRect(el) {
  return {
    x: parseInt(el.style.left) || 0,
    y: parseInt(el.style.top) || 0,
    w: parseInt(el.style.width) || 120,
    h: parseInt(el.style.height) || 48,
  };
}

function rectsOverlap(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x &&
         a.y < b.y + b.h && a.y + a.h > b.y;
}

function clampToCanvas(el) {
  const cr = canvas.getBoundingClientRect();
  let x = parseInt(el.style.left) || 0;
  let y = parseInt(el.style.top) || 0;
  const w = parseInt(el.style.width) || 120;
  const h = parseInt(el.style.height) || 48;
  x = Math.max(0, Math.min(x, cr.width - 40));
  y = Math.max(0, Math.min(y, cr.height - 24));
  el.style.left = x + 'px';
  el.style.top = y + 'px';
}

function resolveCollisions(movedId) {
  if (!pushEnabled) return;

  const cRect = canvas.getBoundingClientRect();

  // BFS: start from movedId, push overlapping panels, cascade
  const queue = [movedId];
  const processed = new Set();

  while (queue.length > 0) {
    const currentId = queue.shift();
    if (processed.has(currentId)) continue;
    processed.add(currentId);

    const current = panels[currentId];
    if (!current) continue;
    const cr = getPanelRect(current.el);

    for (const [otherId, other] of Object.entries(panels)) {
      if (otherId === currentId || processed.has(otherId)) continue;

      const or = getPanelRect(other.el);
      if (!rectsOverlap(cr, or)) continue;

      // Calculate overlap on each push direction
      const pushRight = (cr.x + cr.w) - or.x;
      const pushLeft  = (or.x + or.w) - cr.x;
      const pushDown  = (cr.y + cr.h) - or.y;
      const pushUp    = (or.y + or.h) - cr.y;

      const min = Math.min(pushRight, pushLeft, pushDown, pushUp);

      if (min === pushRight) {
        other.el.style.left = snapV(cr.x + cr.w + PUSH_GAP) + 'px';
      } else if (min === pushLeft) {
        other.el.style.left = snapV(cr.x - or.w - PUSH_GAP) + 'px';
      } else if (min === pushDown) {
        other.el.style.top = snapV(cr.y + cr.h + PUSH_GAP) + 'px';
      } else {
        other.el.style.top = snapV(cr.y - or.h - PUSH_GAP) + 'px';
      }

      // Clamp so panels can't leave the canvas
      clampToCanvas(other.el);
      updateDims(otherId);
      queue.push(otherId);
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ZONE DIVIDERS â€” resize inner boxes within panels
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function initZoneDividers(panelId) {
  const el = panels[panelId].el;
  const body = el.querySelector('.panel-body');
  if (!body) return;

  const zones = [...body.querySelectorAll(':scope > .drop-zone')];
  if (zones.length < 2) return;

  // Fix zone heights from their current rendered size
  zones.forEach(z => {
    const h = z.getBoundingClientRect().height;
    z.style.height = Math.max(16, h) + 'px';
    z.style.flex = 'none';
    z.style.minHeight = '16px';
    z.style.overflow = 'auto';
  });

  // Insert dividers between zones
  for (let i = zones.length - 1; i > 0; i--) {
    const div = document.createElement('div');
    div.className = 'zone-divider';
    body.insertBefore(div, zones[i]);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UNDO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function saveUndoState() {
  const pd = {};
  for (const [id, p] of Object.entries(panels)) {
    pd[id] = { template: p.template, title: p.title };
  }
  undoStack.push({ html: canvas.innerHTML, pd, counter: panelCounter, sel: selectedPanelId });
  if (undoStack.length > MAX_UNDO) undoStack.shift();
}

function undo() {
  if (undoStack.length === 0) return;
  const s = undoStack.pop();
  canvas.innerHTML = s.html;
  panelCounter = s.counter;
  panels = {};
  canvas.querySelectorAll('.panel').forEach(el => {
    panels[el.id] = { el, template: s.pd[el.id]?.template || 'card', title: s.pd[el.id]?.title || 'PANEL' };
  });
  selectPanel(s.sel);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMPONENT LIBRARY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const COMPONENT_LIB = [
  {
    section: 'WINDOWS',
    icon: 'â—»',
    items: [
      { id: 'win-card', icon: 'â—»', label: 'Card Panel', hint: 'empty', template: 'card' },
      { id: 'win-vault', icon: 'ğŸ“', label: 'Vault Picker', hint: 'files', template: 'vault' },
      { id: 'win-toolbar', icon: 'ğŸ”§', label: 'Toolbar Strip', hint: 'controls', template: 'toolbar' },
      { id: 'win-chat', icon: 'ğŸ’¬', label: 'Chat Window', hint: 'messages', template: 'chat' },
      { id: 'win-artifacts', icon: 'ğŸ“‹', label: 'Artifacts Panel', hint: 'sidebar', template: 'artifacts' },
      { id: 'win-stats', icon: 'ğŸ“Š', label: 'Stats Card', hint: 'metrics', template: 'stats' },
      { id: 'win-sessions', icon: 'ğŸ•', label: 'Session List', hint: 'recent', template: 'sessions' },
      { id: 'win-settings', icon: 'âš™', label: 'Settings Panel', hint: 'config', template: 'settings' },
    ],
  },
  {
    section: 'BUTTONS',
    icon: 'â–£',
    items: [
      { id: 'btn-primary', icon: 'â–£', label: 'Primary Button', hint: 'action', html: '<span class="c-btn-primary">BUTTON</span>' },
      { id: 'btn-outline', icon: 'â–¢', label: 'Outline Button', hint: 'alt', html: '<span class="c-btn-outline">BUTTON</span>' },
      { id: 'btn-ghost', icon: 'â–«', label: 'Ghost Button', hint: 'subtle', html: '<span class="c-btn-ghost">Button</span>' },
      { id: 'btn-icon', icon: 'âŠ¡', label: 'Icon Button', hint: 'compact', html: '<span class="c-btn-icon">âš™</span>' },
      { id: 'btn-start', icon: 'â–¶', label: 'START Button', hint: 'go', html: '<span class="c-btn-primary">START</span>' },
      { id: 'btn-end', icon: 'â¹', label: 'END Button', hint: 'stop', html: '<span class="c-btn-outline">END SESSION</span>' },
    ],
  },
  {
    section: 'INPUTS',
    icon: 'â–­',
    items: [
      { id: 'inp-text', icon: 'â–­', label: 'Text Input', hint: 'type', html: '<span class="c-input">Enter text...</span>' },
      { id: 'inp-search', icon: 'ğŸ”', label: 'Search Input', hint: 'filter', html: '<span class="c-input">ğŸ” Search...</span>' },
      { id: 'inp-select', icon: 'â–¾', label: 'Dropdown', hint: 'pick', html: '<span class="c-select">Select option â–¾</span>' },
      { id: 'inp-textarea', icon: 'â–¤', label: 'Text Area', hint: 'multi', html: '<span class="c-textarea">Multi-line input...</span>' },
      { id: 'inp-topic', icon: 'âœ', label: 'Topic Input', hint: 'tutor', html: '<span class="c-input">Topic...</span>' },
    ],
  },
  {
    section: 'CHIPS & BADGES',
    icon: 'â—‰',
    items: [
      { id: 'chip-course', icon: 'â—‰', label: 'Course Chip', hint: 'toggle', html: '<span class="c-chip">EBP</span>' },
      { id: 'chip-active', icon: 'â—‰', label: 'Active Chip', hint: 'on', html: '<span class="c-chip on">ACTIVE</span>' },
      { id: 'badge-default', icon: 'â—', label: 'Badge', hint: 'label', html: '<span class="c-badge">Core</span>' },
      { id: 'badge-live', icon: 'â—', label: 'Live Badge', hint: 'status', html: '<span class="c-badge green">LIVE</span>' },
      { id: 'badge-info', icon: 'â—', label: 'Info Badge', hint: 'info', html: '<span class="c-badge blue">INFO</span>' },
      { id: 'chip-session', icon: 'â±', label: 'Session Chip', hint: 'recent', html: '<span class="c-session"><span class="dot green"></span>Core<span style="opacity:0.5">5t</span></span>' },
    ],
  },
  {
    section: 'CONTROLS',
    icon: 'â˜°',
    items: [
      { id: 'ctrl-toggle', icon: 'â‡”', label: 'Toggle Group', hint: 'switch', html: '<span class="c-toggle-group"><span class="c-toggle-btn on">A</span><span class="c-toggle-btn">B</span></span>' },
      { id: 'ctrl-check', icon: 'â˜‘', label: 'Checkbox', hint: 'bool', html: '<span class="c-check"><span class="box"></span>Option</span>' },
      { id: 'ctrl-model', icon: 'ğŸ¤–', label: 'Model Toggle', hint: 'AI', html: '<span class="c-toggle-group"><span class="c-toggle-btn on">codex</span><span class="c-toggle-btn">OR</span></span>' },
      { id: 'ctrl-web', icon: 'ğŸŒ', label: 'Web Search', hint: 'toggle', html: '<span class="c-check"><span class="box"></span>Web</span>' },
      { id: 'ctrl-mode', icon: 'ğŸ¯', label: 'Mode Select', hint: 'tutor', html: '<span class="c-select">Mode: LEARN â–¾</span>' },
      { id: 'ctrl-chain', icon: 'ğŸ”—', label: 'Chain Select', hint: 'tutor', html: '<span class="c-select">Chain: First Exposure â–¾</span>' },
    ],
  },
  {
    section: 'TEXT & LABELS',
    icon: 'Aa',
    items: [
      { id: 'txt-header', icon: 'H', label: 'Section Header', hint: 'arcade', html: '<span class="c-label">HEADER</span>' },
      { id: 'txt-label', icon: 'L', label: 'Muted Label', hint: 'small', html: '<span class="c-label-muted">Label</span>' },
      { id: 'txt-body', icon: 'T', label: 'Body Text', hint: 'content', html: '<span class="c-text">Body text content</span>' },
      { id: 'txt-muted', icon: 't', label: 'Muted Text', hint: 'info', html: '<span class="c-text-muted">Muted text</span>' },
      { id: 'txt-icon', icon: 'âŠ›', label: 'Icon + Text', hint: 'meta', html: '<span class="c-icon-text">ğŸ’¬ 5 turns</span>' },
    ],
  },
  {
    section: 'TREE ITEMS',
    icon: 'ğŸŒ¿',
    items: [
      { id: 'tree-folder', icon: 'ğŸ“', label: 'Folder', hint: 'expand', html: '<div class="c-tree-folder"><span class="box"></span><span style="color:var(--muted);font-size:9px">â–¶</span><span style="color:var(--yellow)">ğŸ“</span>Folder Name</div>' },
      { id: 'tree-file', icon: 'ğŸ“„', label: 'File', hint: 'leaf', html: '<div class="c-tree-file"><span class="box"></span><span style="color:var(--blue)">ğŸ“„</span>File.md</div>' },
      { id: 'tree-folder-open', icon: 'ğŸ“‚', label: 'Open Folder', hint: 'exp', html: '<div class="c-tree-folder"><span class="box"></span><span style="color:var(--muted);font-size:9px">â–¼</span><span style="color:var(--yellow)">ğŸ“‚</span>Open Folder</div>' },
    ],
  },
  {
    section: 'DATA DISPLAY',
    icon: 'ğŸ“Š',
    items: [
      { id: 'data-stat', icon: 'ğŸ“Š', label: 'Stat Block', hint: 'number', html: '<span class="c-stat"><span class="val">42</span><span class="lbl">TURNS</span></span>' },
      { id: 'data-progress', icon: 'â”', label: 'Progress Bar', hint: 'bar', html: '<div class="c-progress"><div class="fill"></div></div>' },
      { id: 'data-divider', icon: 'â”€', label: 'Divider', hint: 'line', html: '<span class="c-divider"></span>' },
      { id: 'data-divider-thick', icon: 'â”', label: 'Thick Divider', hint: 'bold', html: '<span class="c-divider-thick"></span>' },
    ],
  },
  {
    section: 'CHAT',
    icon: 'ğŸ’¬',
    items: [
      { id: 'chat-user', icon: 'ğŸ‘¤', label: 'User Message', hint: 'right', html: '<div class="c-chat-user">What is the brachial plexus?</div>' },
      { id: 'chat-ai', icon: 'ğŸ¤–', label: 'AI Response', hint: 'left', html: '<div class="c-chat-ai">The brachial plexus is a network of nerves...</div>' },
      { id: 'chat-input', icon: 'âœ', label: 'Chat Input', hint: 'send', html: '<div style="display:flex;gap:4px;width:100%"><span class="c-input" style="flex:1">Type your message...</span><span class="c-btn-primary">SEND</span></div>' },
    ],
  },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WINDOW TEMPLATES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function getWindowTemplate(template) {
  switch (template) {
    case 'card': return { title: 'PANEL', w: 300, h: 200, zones: [{ id: 'main', dir: 'v', items: [] }] };
    case 'vault': return {
      title: 'VAULT FILES', w: 500, h: 380,
      zones: [
        { id: 'chips', dir: 'h', items: [
          { html: '<span class="c-chip on">EBP</span>' },
          { html: '<span class="c-chip">ExPhys</span>' },
          { html: '<span class="c-chip">MS1</span>' },
          { html: '<span class="c-chip">Neuro</span>' },
          { html: '<span class="c-chip">TI</span>' },
          { html: '<span class="c-input">ğŸ” Filter...</span>' },
        ]},
        { id: 'tree', dir: 'v', fill: true, items: [
          { html: '<div class="c-tree-folder"><span class="box"></span><span style="color:var(--muted);font-size:9px">â–¼</span><span style="color:var(--yellow)">ğŸ“‚</span>Evidence Based Practice</div>' },
          { html: '<div class="c-tree-file"><span class="box"></span><span style="color:var(--blue)">ğŸ“„</span>Week 1 - Intro to EBP.md</div>' },
          { html: '<div class="c-tree-file"><span class="box"></span><span style="color:var(--blue)">ğŸ“„</span>Week 2 - PICO Framework.md</div>' },
          { html: '<div class="c-tree-file"><span class="box"></span><span style="color:var(--blue)">ğŸ“„</span>Week 3 - Study Designs.md</div>' },
          { html: '<div class="c-tree-folder"><span class="box"></span><span style="color:var(--muted);font-size:9px">â–¶</span><span style="color:var(--yellow)">ğŸ“</span>Exercise Physiology</div>' },
          { html: '<div class="c-tree-folder"><span class="box"></span><span style="color:var(--muted);font-size:9px">â–¶</span><span style="color:var(--yellow)">ğŸ“</span>Movement Science 1</div>' },
          { html: '<div class="c-tree-folder"><span class="box"></span><span style="color:var(--muted);font-size:9px">â–¼</span><span style="color:var(--yellow)">ğŸ“‚</span>Neuroscience</div>' },
          { html: '<div class="c-tree-file"><span class="box"></span><span style="color:var(--blue)">ğŸ“„</span>Cranial Nerves.md</div>' },
          { html: '<div class="c-tree-file"><span class="box"></span><span style="color:var(--blue)">ğŸ“„</span>Spinal Cord Anatomy.md</div>' },
          { html: '<div class="c-tree-folder"><span class="box"></span><span style="color:var(--muted);font-size:9px">â–¶</span><span style="color:var(--yellow)">ğŸ“</span>Therapeutic Intervention</div>' },
        ]},
        { id: 'footer', dir: 'h', items: [
          { html: '<span class="c-text-muted">3 folders, 2 files</span>' },
          { html: '<span class="c-btn-ghost">âœ• CLEAR</span>' },
        ]},
      ],
    };
    case 'toolbar': return {
      title: 'TOOLBAR', w: 600, h: 44,
      zones: [{ id: 'controls', dir: 'h', fill: true, items: [
        { html: '<span class="c-select">Mode: LEARN â–¾</span>' },
        { html: '<span class="c-select">Chain: First Exposure â–¾</span>' },
        { html: '<span class="c-input">Topic...</span>' },
        { html: '<span class="c-toggle-group"><span class="c-toggle-btn on">codex</span><span class="c-toggle-btn">OR</span></span>' },
        { html: '<span class="c-check"><span class="box"></span>Web</span>' },
        { html: '<span class="c-btn-primary">START</span>' },
      ]}],
    };
    case 'chat': return {
      title: 'CHAT', w: 450, h: 350,
      zones: [
        { id: 'messages', dir: 'v', fill: true, items: [
          { html: '<div class="c-chat-user">What muscles make up the rotator cuff?</div>' },
          { html: '<div class="c-chat-ai">The rotator cuff is composed of four muscles: supraspinatus, infraspinatus, teres minor, and subscapularis (SITS).</div>' },
        ]},
        { id: 'input', dir: 'h', items: [
          { html: '<span class="c-input" style="flex:1">Type your message...</span>' },
          { html: '<span class="c-btn-primary">SEND</span>' },
        ]},
      ],
    };
    case 'artifacts': return {
      title: 'ARTIFACTS', w: 260, h: 300,
      zones: [
        { id: 'header', dir: 'h', items: [
          { html: '<span class="c-label">ARTIFACTS</span>' },
          { html: '<span class="c-badge">3</span>' },
        ]},
        { id: 'list', dir: 'v', fill: true, items: [
          { html: '<div style="padding:4px 8px;border:1px solid var(--primary-dim);width:100%"><span class="c-badge blue">CARD</span> <span class="c-text" style="margin-left:4px">Brachial Plexus</span></div>' },
          { html: '<div style="padding:4px 8px;border:1px solid rgba(255,255,255,0.06);width:100%"><span class="c-badge">NOTE</span> <span class="c-text" style="margin-left:4px">Muscle Origins</span></div>' },
          { html: '<div style="padding:4px 8px;border:1px solid rgba(255,255,255,0.06);width:100%"><span class="c-badge green">MAP</span> <span class="c-text" style="margin-left:4px">Spinal Nerves</span></div>' },
        ]},
      ],
    };
    case 'stats': return {
      title: 'STATS', w: 320, h: 100,
      zones: [{ id: 'stats', dir: 'h', items: [
        { html: '<span class="c-stat"><span class="val">12</span><span class="lbl">TURNS</span></span>' },
        { html: '<span class="c-stat"><span class="val">3</span><span class="lbl">CARDS</span></span>' },
        { html: '<span class="c-stat"><span class="val">45m</span><span class="lbl">TIME</span></span>' },
        { html: '<span class="c-stat"><span class="val">85%</span><span class="lbl">SCORE</span></span>' },
      ]}],
    };
    case 'sessions': return {
      title: 'RECENT SESSIONS', w: 500, h: 36,
      zones: [{ id: 'chips', dir: 'h', items: [
        { html: '<span class="c-label-muted">RECENT:</span>' },
        { html: '<span class="c-session"><span class="dot green"></span>Core<span style="opacity:0.5">5t</span></span>' },
        { html: '<span class="c-session"><span class="dot gray"></span>EBP Sprint<span style="opacity:0.5">3t</span></span>' },
        { html: '<span class="c-session"><span class="dot gray"></span>Neuro Fix<span style="opacity:0.5">8t</span></span>' },
        { html: '<span class="c-session"><span class="dot gray"></span>MS1 Review<span style="opacity:0.5">2t</span></span>' },
      ]}],
    };
    case 'settings': return {
      title: 'SETTINGS', w: 280, h: 240,
      zones: [{ id: 'options', dir: 'v', fill: true, items: [
        { html: '<span class="c-label">MODE</span>' },
        { html: '<span class="c-select" style="width:100%">Core â–¾</span>' },
        { html: '<span class="c-label">CHAIN</span>' },
        { html: '<span class="c-select" style="width:100%">First Exposure (Core) â–¾</span>' },
        { html: '<span class="c-label">MODEL</span>' },
        { html: '<span class="c-toggle-group"><span class="c-toggle-btn on">codex</span><span class="c-toggle-btn">OR</span></span>' },
        { html: '<span class="c-divider"></span>' },
        { html: '<span class="c-check"><span class="box"></span>Web Search</span>' },
        { html: '<span class="c-btn-primary" style="width:100%;text-align:center">START SESSION</span>' },
      ]}],
    };
    default: return { title: 'PANEL', w: 300, h: 200, zones: [{ id: 'main', dir: 'v', items: [] }] };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDER PALETTE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderPalette() {
  const container = document.getElementById('paletteScroll');
  container.innerHTML = '';

  COMPONENT_LIB.forEach((section, si) => {
    const sec = document.createElement('div');
    sec.className = 'pal-section';

    const header = document.createElement('div');
    header.className = 'pal-section-header';
    header.innerHTML = `<span>${section.section}</span><span class="arrow open">â–¶</span>`;
    header.onclick = () => {
      const body = sec.querySelector('.pal-section-body');
      const arrow = header.querySelector('.arrow');
      body.classList.toggle('closed');
      arrow.classList.toggle('open');
    };
    sec.appendChild(header);

    const body = document.createElement('div');
    body.className = 'pal-section-body';

    section.items.forEach(item => {
      const el = document.createElement('div');
      el.className = 'pal-item';
      el.dataset.componentId = item.id;
      el.dataset.template = item.template || '';
      el.dataset.html = item.html || '';
      el.innerHTML = `<span class="icon">${item.icon}</span><span class="label">${item.label}</span><span class="hint">${item.hint}</span>`;

      el.addEventListener('mousedown', startPaletteDrag);
      body.appendChild(el);
    });

    sec.appendChild(body);
    container.appendChild(sec);
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PALETTE DRAG â†’ CANVAS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function startPaletteDrag(e) {
  const item = e.currentTarget;
  const template = item.dataset.template;
  const html = item.dataset.html;
  const compId = item.dataset.componentId;

  paletteDrag = { compId, template, html, startX: e.clientX, startY: e.clientY, active: false };

  // Clone for ghost
  ghost.innerHTML = item.innerHTML;
  ghost.style.display = 'flex';
  ghost.style.alignItems = 'center';
  ghost.style.gap = '6px';
  ghost.style.padding = '6px 10px';
  ghost.style.background = 'rgba(239,68,68,0.15)';
  ghost.style.border = '1px solid var(--primary)';
  ghost.style.fontSize = '11px';
  ghost.style.left = e.clientX + 8 + 'px';
  ghost.style.top = e.clientY + 8 + 'px';

  e.preventDefault();
}

document.addEventListener('mousemove', (e) => {
  // Palette drag
  if (paletteDrag) {
    ghost.style.left = e.clientX + 8 + 'px';
    ghost.style.top = e.clientY + 8 + 'px';

    const dx = e.clientX - paletteDrag.startX;
    const dy = e.clientY - paletteDrag.startY;
    if (!paletteDrag.active && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) {
      paletteDrag.active = true;
      canvas.classList.add('drop-active');
    }

    // Highlight drop target panel
    document.querySelectorAll('.panel').forEach(p => p.classList.remove('drop-target'));
    document.querySelectorAll('.drop-zone').forEach(z => z.classList.remove('highlight'));
    const target = document.elementFromPoint(e.clientX, e.clientY);
    if (target) {
      const zone = target.closest('.drop-zone');
      if (zone) zone.classList.add('highlight');
      else {
        const panel = target.closest('.panel');
        if (panel) panel.classList.add('drop-target');
      }
    }
    return;
  }

  // Zone divider drag (inner box resize â€” row or col)
  if (zoneDragState) {
    if (zoneDragState.direction === 'col') {
      const dx = e.clientX - zoneDragState.startY;
      const newLeftW = Math.max(40, zoneDragState.startAboveH + dx);
      const newRightW = Math.max(40, zoneDragState.startBelowH - dx);
      if (newLeftW >= 40 && newRightW >= 40) {
        zoneDragState.zoneAbove.style.width = snapV(newLeftW) + 'px';
        zoneDragState.zoneBelow.style.width = snapV(newRightW) + 'px';
      }
    } else {
      const dy = e.clientY - zoneDragState.startY;
      const newAboveH = Math.max(16, zoneDragState.startAboveH + dy);
      const newBelowH = Math.max(16, zoneDragState.startBelowH - dy);
      if (newAboveH >= 16 && newBelowH >= 16) {
        zoneDragState.zoneAbove.style.height = snapV(newAboveH) + 'px';
        zoneDragState.zoneBelow.style.height = snapV(newBelowH) + 'px';
      }
    }
    return;
  }

  // Item resize drag
  if (itemResizeState) {
    const dx = e.clientX - itemResizeState.startX;
    const dy = e.clientY - itemResizeState.startY;
    const d = itemResizeState.dir;
    const el = itemResizeState.el;
    if (d === 'se' || d === 'e') {
      el.style.width = Math.max(40, itemResizeState.startW + dx) + 'px';
    }
    if (d === 'se' || d === 's') {
      el.style.height = Math.max(20, itemResizeState.startH + dy) + 'px';
    }
    return;
  }

  // Hand tool drag â€” Push ON: reorder in place, Push OFF: float out
  if (handDragState) {
    const dx = e.clientX - handDragState.startX;
    const dy = e.clientY - handDragState.startY;
    const allEls = handDragState.group || [handDragState.el];
    if (!handDragState.moved && (Math.abs(dx) > 4 || Math.abs(dy) > 4)) {
      handDragState.moved = true;

      if (pushEnabled) {
        // Push ON: stay in DOM, reorder among siblings
        allEls.forEach(el => { el.style.pointerEvents = 'none'; el.style.opacity = '0.6'; });
      } else {
        // Push OFF: detach and float
        handDragState.groupRects = [];
        const primaryRect = handDragState.el.getBoundingClientRect();
        allEls.forEach(el => {
          const rect = el.getBoundingClientRect();
          handDragState.groupRects.push({
            el,
            origParent: el.parentElement,
            origNext: el.nextElementSibling,
            offX: rect.left - primaryRect.left,
            offY: rect.top - primaryRect.top,
            w: rect.width,
          });
          el.style.pointerEvents = 'none';
          el.remove();
          el.style.position = 'fixed';
          el.style.left = rect.left + 'px';
          el.style.top = rect.top + 'px';
          el.style.width = rect.width + 'px';
          el.style.zIndex = '10000';
          el.style.opacity = '0.85';
          el.style.boxShadow = '0 0 16px rgba(34,211,238,0.6)';
          document.body.appendChild(el);
        });
        handDragState.floating = true;
        handDragState.offsetX = e.clientX - primaryRect.left;
        handDragState.offsetY = e.clientY - primaryRect.top;
      }
    }
    if (handDragState.moved) {
      document.querySelectorAll('.drop-zone').forEach(z => z.classList.remove('highlight'));

      if (handDragState.floating) {
        // Float mode: follow cursor
        const baseX = e.clientX - handDragState.offsetX;
        const baseY = e.clientY - handDragState.offsetY;
        (handDragState.groupRects || []).forEach(gr => {
          gr.el.style.left = (baseX + gr.offX) + 'px';
          gr.el.style.top = (baseY + gr.offY) + 'px';
        });
        const hoverTarget = document.elementFromPoint(e.clientX, e.clientY);
        const targetZone = hoverTarget?.closest('.drop-zone');
        if (targetZone) targetZone.classList.add('highlight');
      } else {
        // Push ON: reorder among siblings â€” items push each other
        const hoverTarget = document.elementFromPoint(e.clientX, e.clientY);
        const targetZone = hoverTarget?.closest('.drop-zone');
        if (targetZone) {
          targetZone.classList.add('highlight');
          insertAtCursor(handDragState.el, targetZone, e);
          if (handDragState.group) {
            let ref = handDragState.el;
            for (const gel of handDragState.group) {
              if (gel === handDragState.el) continue;
              if (ref.nextSibling) targetZone.insertBefore(gel, ref.nextSibling);
              else targetZone.appendChild(gel);
              ref = gel;
            }
          }
        }
      }
    }
    return;
  }

  // Panel drag/resize
  if (dragState) {
    const dx = e.clientX - dragState.startX;
    const dy = e.clientY - dragState.startY;
    const el = panels[dragState.panelId].el;
    const sr = dragState.startRect;

    if (dragState.type === 'move') {
      el.style.left = snapV(sr.x + dx) + 'px';
      el.style.top = snapV(sr.y + dy) + 'px';
      clampToCanvas(el);
    } else {
      let nx = sr.x, ny = sr.y, nw = sr.w, nh = sr.h;
      const d = dragState.dir;
      if (d.includes('e')) nw = Math.max(120, sr.w + dx);
      if (d.includes('w')) { nw = Math.max(120, sr.w - dx); nx = sr.x + sr.w - nw; }
      if (d.includes('s')) nh = Math.max(36, sr.h + dy);
      if (d.includes('n')) { nh = Math.max(36, sr.h - dy); ny = sr.y + sr.h - nh; }
      el.style.left = snapV(nx) + 'px';
      el.style.top = snapV(ny) + 'px';
      el.style.width = snapV(nw) + 'px';
      el.style.height = snapV(nh) + 'px';
    }
    updateDims(dragState.panelId);
    updateInfoBar(dragState.panelId);
    resolveCollisions(dragState.panelId);
    closeGaps();
    return;
  }

  // Item drag â€” Push ON: reorder in place, Push OFF: float out
  if (itemDragState) {
    const dx = e.clientX - itemDragState.startX;
    const dy = e.clientY - itemDragState.startY;
    const allItems = itemDragState.group || [itemDragState.el];
    if (!itemDragState.moved && (Math.abs(dx) > 4 || Math.abs(dy) > 4)) {
      itemDragState.moved = true;

      if (pushEnabled) {
        // Push ON: stay in DOM, reorder among siblings
        allItems.forEach(el => { el.classList.add('dragging-item'); el.style.pointerEvents = 'none'; });
      } else {
        // Push OFF: detach and float
        itemDragState.groupRects = [];
        const primaryRect = itemDragState.el.getBoundingClientRect();
        allItems.forEach(el => {
          const rect = el.getBoundingClientRect();
          itemDragState.groupRects.push({
            el,
            origParent: el.parentElement,
            origNext: el.nextElementSibling,
            offX: rect.left - primaryRect.left,
            offY: rect.top - primaryRect.top,
            w: rect.width,
          });
          el.classList.add('dragging-item');
          el.style.pointerEvents = 'none';
          el.remove();
          el.style.position = 'fixed';
          el.style.left = rect.left + 'px';
          el.style.top = rect.top + 'px';
          el.style.width = rect.width + 'px';
          el.style.zIndex = '10000';
          el.style.opacity = '0.85';
          el.style.boxShadow = '0 0 16px rgba(34,211,238,0.6)';
          document.body.appendChild(el);
        });
        itemDragState.floating = true;
        itemDragState.offsetX = e.clientX - primaryRect.left;
        itemDragState.offsetY = e.clientY - primaryRect.top;
      }
    }
    if (itemDragState.moved) {
      document.querySelectorAll('.drop-zone').forEach(z => z.classList.remove('highlight'));

      if (itemDragState.floating) {
        // Float mode: follow cursor
        const baseX = e.clientX - itemDragState.offsetX;
        const baseY = e.clientY - itemDragState.offsetY;
        (itemDragState.groupRects || []).forEach(gr => {
          gr.el.style.left = (baseX + gr.offX) + 'px';
          gr.el.style.top = (baseY + gr.offY) + 'px';
        });
        const target = document.elementFromPoint(e.clientX, e.clientY);
        const targetZone = target?.closest('.drop-zone');
        if (targetZone) targetZone.classList.add('highlight');
      } else {
        // Push ON: reorder â€” items push each other
        const target = document.elementFromPoint(e.clientX, e.clientY);
        const targetZone = target?.closest('.drop-zone');
        if (targetZone) {
          targetZone.classList.add('highlight');
          insertAtCursor(itemDragState.el, targetZone, e);
          if (itemDragState.group) {
            let ref = itemDragState.el;
            for (const gel of itemDragState.group) {
              if (gel === itemDragState.el) continue;
              if (ref.nextSibling) targetZone.insertBefore(gel, ref.nextSibling);
              else targetZone.appendChild(gel);
              ref = gel;
            }
          }
        }
      }
    }
  }
});

document.addEventListener('mouseup', (e) => {
  // Zone divider end
  if (zoneDragState) {
    zoneDragState.divider.classList.remove('active');
    zoneDragState = null;
    updatePrompt();
    return;
  }

  // Item resize end
  if (itemResizeState) {
    itemResizeState = null;
    updatePrompt();
    return;
  }

  // Hand tool end
  if (handDragState) {
    const allEls = handDragState.group || [handDragState.el];

    if (handDragState.floating && handDragState.groupRects) {
      // Float mode drop: find target zone under cursor
      allEls.forEach(el => { el.style.pointerEvents = ''; });
      const dropTarget = document.elementFromPoint(e.clientX, e.clientY);
      const targetZone = dropTarget?.closest('.drop-zone');

      handDragState.groupRects.forEach(gr => {
        gr.el.style.position = '';
        gr.el.style.left = '';
        gr.el.style.top = '';
        gr.el.style.width = '';
        gr.el.style.zIndex = '';
        gr.el.style.boxShadow = '';
        gr.el.style.opacity = '';
        gr.el.classList.remove('hand-target');
        if (gr.el.parentElement === document.body) gr.el.remove();

        if (targetZone) {
          insertAtCursor(gr.el, targetZone, e);
        } else {
          if (gr.origNext && gr.origParent?.contains(gr.origNext)) {
            gr.origParent.insertBefore(gr.el, gr.origNext);
          } else if (gr.origParent) {
            gr.origParent.appendChild(gr.el);
          }
        }
      });
    } else {
      // Push ON or no movement â€” clean up styles
      allEls.forEach(el => {
        el.classList.remove('hand-target');
        el.style.opacity = '';
        el.style.pointerEvents = '';
      });
    }
    document.querySelectorAll('.drop-zone').forEach(z => z.classList.remove('highlight'));
    handDragState = null;
    updatePrompt();
    return;
  }

  // Palette drop
  if (paletteDrag && paletteDrag.active) {
    ghost.style.display = 'none';
    canvas.classList.remove('drop-active');
    document.querySelectorAll('.panel').forEach(p => p.classList.remove('drop-target'));
    document.querySelectorAll('.drop-zone').forEach(z => z.classList.remove('highlight'));

    const cr = canvas.getBoundingClientRect();
    const dropX = e.clientX - cr.left;
    const dropY = e.clientY - cr.top;

    // Dropping on a zone = add component to it
    const target = document.elementFromPoint(e.clientX, e.clientY);
    const targetZone = target?.closest('.drop-zone');

    saveUndoState();
    if (targetZone && paletteDrag.html) {
      // Add item to existing zone
      const itemEl = document.createElement('div');
      itemEl.className = 'drag-item';
      itemEl.innerHTML = paletteDrag.html;
      targetZone.appendChild(itemEl);
    } else if (paletteDrag.template) {
      // Create new window panel
      createPanel(paletteDrag.template, snapV(dropX), snapV(dropY));
    } else if (paletteDrag.html) {
      // Create a tiny card with the item
      const pid = createPanel('card', snapV(dropX), snapV(dropY));
      const zone = panels[pid].el.querySelector('.drop-zone');
      if (zone) {
        const itemEl = document.createElement('div');
        itemEl.className = 'drag-item';
        itemEl.innerHTML = paletteDrag.html;
        zone.appendChild(itemEl);
      }
    }

    paletteDrag = null;
    return;
  }
  if (paletteDrag) {
    ghost.style.display = 'none';
    paletteDrag = null;
    return;
  }

  // Panel drag/resize end
  if (dragState) {
    panels[dragState.panelId].el.classList.remove('dragging');
    dragState = null;
    updatePrompt();
  }

  // Item drag end
  if (itemDragState) {
    const allItems = itemDragState.group || [itemDragState.el];

    if (itemDragState.floating) {
      // Float mode drop
      const rects = itemDragState.groupRects || [];
      rects.forEach(gr => { gr.el.style.pointerEvents = ''; });
      const dropTarget = document.elementFromPoint(e.clientX, e.clientY);
      const targetZone = dropTarget?.closest('.drop-zone');

      rects.forEach(gr => {
        gr.el.style.position = '';
        gr.el.style.left = '';
        gr.el.style.top = '';
        gr.el.style.width = '';
        gr.el.style.zIndex = '';
        gr.el.style.boxShadow = '';
        gr.el.style.opacity = '';
        gr.el.classList.remove('dragging-item');
        if (gr.el.parentElement === document.body) gr.el.remove();

        if (targetZone) {
          insertAtCursor(gr.el, targetZone, e);
        } else {
          if (gr.origNext && gr.origParent?.contains(gr.origNext)) {
            gr.origParent.insertBefore(gr.el, gr.origNext);
          } else if (gr.origParent) {
            gr.origParent.appendChild(gr.el);
          }
        }
      });
    } else {
      // Push ON or no movement â€” clean up styles
      allItems.forEach(el => {
        el.classList.remove('dragging-item');
        el.style.pointerEvents = '';
        el.style.opacity = '';
      });
    }

    document.querySelectorAll('.drop-zone').forEach(z => z.classList.remove('highlight'));
    updatePrompt();
    itemDragState = null;
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CREATE PANEL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function createPanel(template, x, y) {
  const tmpl = getWindowTemplate(template);
  const id = 'p' + (++panelCounter);

  const el = document.createElement('div');
  el.className = 'panel';
  el.id = id;
  el.style.left = x + 'px';
  el.style.top = y + 'px';
  el.style.width = tmpl.w + 'px';
  el.style.height = tmpl.h + 'px';

  // Resize handles
  ['n','s','e','w','ne','nw','se','sw'].forEach(d => {
    const h = document.createElement('div');
    h.className = `rh ${d}`;
    h.dataset.dir = d;
    el.appendChild(h);
  });

  // Header
  const header = document.createElement('div');
  header.className = 'panel-header';
  header.innerHTML = `<span class="title">${tmpl.title}</span><span class="dims">${tmpl.w}Ã—${tmpl.h}</span><button class="close-btn" onclick="saveUndoState(); removePanel('${id}')" title="Delete">âœ•</button>`;
  el.appendChild(header);

  // Body
  const body = document.createElement('div');
  body.className = 'panel-body';

  tmpl.zones.forEach(zone => {
    const zoneEl = document.createElement('div');
    let cls = 'drop-zone';
    if (zone.dir === 'v') cls += ' vertical';
    if (zone.fill && zone.dir === 'h') cls += ' horizontal-fill';
    zoneEl.className = cls;
    zoneEl.dataset.zoneId = `${id}-${zone.id}`;

    zone.items.forEach(item => {
      const itemEl = document.createElement('div');
      itemEl.className = 'drag-item';
      if (item.html) itemEl.innerHTML = item.html;
      zoneEl.appendChild(itemEl);
    });

    body.appendChild(zoneEl);
  });

  el.appendChild(body);
  canvas.appendChild(el);

  panels[id] = { el, template, title: tmpl.title };
  selectPanel(id);
  updateDims(id);

  // Init zone dividers after layout is computed
  requestAnimationFrame(() => initZoneDividers(id));

  return id;
}

function removePanel(id) {
  if (panels[id]) {
    panels[id].el.remove();
    delete panels[id];
    if (selectedPanelId === id) selectPanel(null);
  }
}

function deleteSelected() {
  if (selectedPanelId) { saveUndoState(); removePanel(selectedPanelId); }
}

function detachElement() {
  const els = getSelectedGroup();
  if (els.length === 0) return;
  saveUndoState();

  els.forEach(el => {
    const parentZone = el.parentElement;
    if (!parentZone) return;

    // Walk up: find an outer zone that isn't the current parent
    // parentZone â†’ its parent â†’ look for a drop-zone ancestor
    const grandparent = parentZone.parentElement;
    if (!grandparent) return;

    // Option 1: grandparent IS a zone (nested box inside zone)
    if (grandparent.classList.contains('drop-zone')) {
      const ref = parentZone.nextSibling;
      if (ref) grandparent.insertBefore(el, ref);
      else grandparent.appendChild(el);
      return;
    }

    // Option 2: walk up further to find ANY ancestor zone
    const outerZone = grandparent.closest('.drop-zone');
    if (outerZone) {
      // Insert after the current parent zone in the outer zone
      const ancestor = parentZone.closest('.drop-zone:not(:scope)') || parentZone;
      let insertRef = ancestor;
      // Walk up to find the direct child of outerZone
      while (insertRef.parentElement && insertRef.parentElement !== outerZone) insertRef = insertRef.parentElement;
      if (insertRef.nextSibling) outerZone.insertBefore(el, insertRef.nextSibling);
      else outerZone.appendChild(el);
      return;
    }

    // Option 3: panel body â€” find or use the first zone
    const panelBody = grandparent.closest('.panel-body') || parentZone.closest('.panel-body');
    if (panelBody) {
      const firstZone = panelBody.querySelector(':scope > .drop-zone');
      if (firstZone && firstZone !== parentZone) {
        firstZone.appendChild(el);
      }
      // If already in the top zone, nothing more to detach
    }
  });
  updatePrompt();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CANVAS MOUSE HANDLERS (move/resize/select)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
canvas.addEventListener('mousedown', (e) => {
  // Safety: reset any stuck pointer-events from prior incomplete drags
  cleanupStuckDragStyles();

  // DEBUG: show what was clicked
  const dbgTag = e.target.tagName.toLowerCase();
  const dbgClass = e.target.className?.toString().substring(0, 40) || '';
  const dbgText = (e.target.textContent || '').substring(0, 20).trim();
  const dbgPE = getComputedStyle(e.target).pointerEvents;
  const dbgDI = e.target.closest('.drag-item');
  const dbgIB = e.target.closest('.inner-box');
  document.getElementById('debugTarget').textContent = `<${dbgTag} class="${dbgClass}"> "${dbgText}"`;
  document.getElementById('debugPE').textContent = dbgPE;

  let dbgAction = 'none';
  if (e.target.closest('.zone-divider') || e.target.closest('.zone-col-divider')) dbgAction = 'zone-divider';
  else if (e.target.closest('.item-rh')) dbgAction = 'item-resize';
  else if (e.target.closest('.rh')) dbgAction = 'panel-resize';
  else if (e.target.closest('.panel-header')) dbgAction = 'panel-header';
  else if (dbgDI) dbgAction = `drag-item(${dbgDI.children[0]?.className || '?'})`;
  else if (dbgIB) dbgAction = 'inner-box';
  else if (e.target.closest('.panel')) dbgAction = 'panel-bg';
  else dbgAction = 'canvas-bg';
  document.getElementById('debugAction').textContent = dbgAction;

  if (paletteDrag) return;

  // Zone divider drag (inner box resize â€” row or column)
  const rowDivider = e.target.closest('.zone-divider');
  const colDivider = e.target.closest('.zone-col-divider');
  const anyDivider = rowDivider || colDivider;
  if (anyDivider) {
    const panel = anyDivider.closest('.panel');
    if (panel) selectPanel(panel.id);

    const isCol = !!colDivider;
    const div = anyDivider;
    let zoneBefore = div.previousElementSibling;
    let zoneAfter = div.nextElementSibling;
    while (zoneBefore && !zoneBefore.classList.contains('drop-zone') && !zoneBefore.classList.contains('zone-row')) zoneBefore = zoneBefore.previousElementSibling;
    while (zoneAfter && !zoneAfter.classList.contains('drop-zone') && !zoneAfter.classList.contains('zone-row')) zoneAfter = zoneAfter.nextElementSibling;

    if (zoneBefore && zoneAfter) {
      saveUndoState();
      div.classList.add('active');
      zoneDragState = {
        direction: isCol ? 'col' : 'row',
        divider: div,
        zoneAbove: zoneBefore,
        zoneBelow: zoneAfter,
        startY: isCol ? e.clientX : e.clientY,
        startAboveH: isCol ? zoneBefore.getBoundingClientRect().width : zoneBefore.getBoundingClientRect().height,
        startBelowH: isCol ? zoneAfter.getBoundingClientRect().width : zoneAfter.getBoundingClientRect().height,
      };
      e.preventDefault();
      return;
    }
  }

  // Hand tool â€” grab any element to move/reorder it
  if (handMode) {
    let target = e.target.closest('.inner-box') || e.target.closest('.drag-item');
    // Fallback: walk up to direct zone child, then nearest-child by distance
    if (!target) {
      const z = e.target.closest('.drop-zone');
      if (z) {
        let w = e.target;
        while (w && w.parentElement !== z) w = w.parentElement;
        if (w && w !== z && !w.classList.contains('zone-divider') && !w.classList.contains('zone-col-divider') && !w.classList.contains('box-label')) {
          target = w;
        } else {
          // Nearest child by distance
          let bestDist = Infinity;
          for (const child of z.children) {
            if (child.classList.contains('zone-divider') || child.classList.contains('zone-col-divider') || child.classList.contains('box-label')) continue;
            const r = child.getBoundingClientRect();
            const cx = Math.max(r.left, Math.min(e.clientX, r.right));
            const cy = Math.max(r.top, Math.min(e.clientY, r.bottom));
            const dist = Math.hypot(e.clientX - cx, e.clientY - cy);
            if (dist < bestDist) { bestDist = dist; target = child; }
          }
          if (bestDist > 20) target = null;
        }
      }
    }
    if (target) {
      const panel = target.closest('.panel');
      if (panel) selectPanel(panel.id);
      selectElement(target, e.shiftKey);
      saveUndoState();
      target.classList.add('hand-target');
      // Collect group elements if dragging a grouped item
      const group = getSelectedGroup();
      const isGroupDrag = group.length > 1 && group.includes(target);
      handDragState = {
        el: target,
        parentZone: target.parentElement,
        startX: e.clientX,
        startY: e.clientY,
        moved: false,
        group: isGroupDrag ? group : null,
      };
      e.preventDefault();
      return;
    }
  }

  const handle = e.target.closest('.rh');
  if (handle) {
    const panel = handle.closest('.panel');
    const id = panel.id;
    deselectElement();
    selectPanel(id);
    saveUndoState();
    dragState = {
      type: 'resize', panelId: id,
      startX: e.clientX, startY: e.clientY,
      startRect: { x: parseInt(panel.style.left), y: parseInt(panel.style.top), w: parseInt(panel.style.width), h: parseInt(panel.style.height) },
      dir: handle.dataset.dir,
    };
    panel.classList.add('dragging');
    e.preventDefault();
    return;
  }

  const header = e.target.closest('.panel-header');
  if (header && !e.target.closest('.close-btn')) {
    const panel = header.closest('.panel');
    const id = panel.id;
    deselectElement();
    selectPanel(id);
    saveUndoState();
    dragState = {
      type: 'move', panelId: id,
      startX: e.clientX, startY: e.clientY,
      startRect: { x: parseInt(panel.style.left), y: parseInt(panel.style.top), w: parseInt(panel.style.width), h: parseInt(panel.style.height) },
    };
    panel.classList.add('dragging');
    e.preventDefault();
    return;
  }

  // Item resize handle â€” must come before drag-item detection
  const itemRH = e.target.closest('.item-rh');
  if (itemRH) {
    const resizeTarget = itemRH.parentElement;
    saveUndoState();
    const rect = resizeTarget.getBoundingClientRect();
    itemResizeState = {
      el: resizeTarget,
      dir: itemRH.dataset.resizedir,
      startX: e.clientX,
      startY: e.clientY,
      startW: rect.width,
      startH: rect.height,
    };
    e.preventDefault();
    e.stopPropagation();
    return;
  }

  // Selectable: drag-item, inner-box, or any direct child of a drop-zone
  let selectable = e.target.closest('.drag-item') || e.target.closest('.inner-box');
  if (!selectable) {
    // Fallback 1: walk up from click target to find direct zone child
    const clickZone = e.target.closest('.drop-zone');
    if (clickZone) {
      let walker = e.target;
      while (walker && walker.parentElement !== clickZone) walker = walker.parentElement;
      if (walker && walker !== clickZone && !walker.classList.contains('zone-divider') && !walker.classList.contains('zone-col-divider') && !walker.classList.contains('box-label')) {
        selectable = walker;
      }
      // Fallback 2: click landed on zone background (gap/padding) â€” find nearest child
      if (!selectable) {
        let bestDist = Infinity;
        for (const child of clickZone.children) {
          if (child.classList.contains('zone-divider') || child.classList.contains('zone-col-divider') || child.classList.contains('box-label')) continue;
          const r = child.getBoundingClientRect();
          const cx = Math.max(r.left, Math.min(e.clientX, r.right));
          const cy = Math.max(r.top, Math.min(e.clientY, r.bottom));
          const dist = Math.hypot(e.clientX - cx, e.clientY - cy);
          if (dist < bestDist) { bestDist = dist; selectable = child; }
        }
        // Only pick nearest if within 20px â€” otherwise treat as empty zone click
        if (bestDist > 20) selectable = null;
      }
    }
  }
  if (selectable) {
    // Find parent zone â€” for elements directly in panel-body, use nearest zone
    let zone = selectable.closest('.drop-zone');
    if (!zone) {
      const body = selectable.closest('.panel-body');
      if (body) zone = body.querySelector('.drop-zone');
    }
    if (zone || selectable.closest('.panel')) {
      const panel = selectable.closest('.panel');
      if (panel) selectPanel(panel.id);
      selectElement(selectable, e.shiftKey);
      saveUndoState();
      const iGroup = getSelectedGroup();
      const isIGroupDrag = iGroup.length > 1 && iGroup.includes(selectable);
      itemDragState = { el: selectable, zone: zone || selectable.parentElement, startX: e.clientX, startY: e.clientY, moved: false, group: isIGroupDrag ? iGroup : null };
      e.preventDefault();
      return;
    }
  }

  const panel = e.target.closest('.panel');
  if (panel) { deselectElement(); selectPanel(panel.id); }
  else { deselectElement(); selectPanel(null); }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SELECTION + INFO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function selectPanel(id) {
  document.querySelectorAll('.panel').forEach(p => p.classList.remove('selected'));
  selectedPanelId = id;
  if (id && panels[id]) {
    panels[id].el.classList.add('selected');
    updateInfoBar(id);
  } else {
    document.getElementById('infoSelected').textContent = 'none';
    document.getElementById('infoPos').textContent = '--';
    document.getElementById('infoSize').textContent = '--';
  }
}

function addItemResizeHandles(el) {
  if (el.querySelector('.item-rh')) return;
  ['se', 'e', 's'].forEach(dir => {
    const h = document.createElement('div');
    h.className = `item-rh ${dir}`;
    h.dataset.resizedir = dir;
    el.appendChild(h);
  });
}

function removeItemResizeHandles(el) {
  el.querySelectorAll('.item-rh').forEach(h => h.remove());
}

function selectElement(el, shiftKey) {
  if (shiftKey && selectedElement) {
    // Shift+click: add to group
    if (!groupedElements.has(selectedElement)) {
      groupedElements.add(selectedElement);
      selectedElement.classList.remove('element-selected');
      selectedElement.classList.add('element-grouped');
      addItemResizeHandles(selectedElement);
    }
    groupedElements.add(el);
    el.classList.add('element-grouped');
    addItemResizeHandles(el);
    selectedElement = el;
    return;
  }

  // Normal click: clear group, select one
  deselectElement();
  selectedElement = el;
  if (el) {
    el.classList.add('element-selected');
    addItemResizeHandles(el);
  }
}

function deselectElement() {
  if (selectedElement) {
    selectedElement.classList.remove('element-selected');
    removeItemResizeHandles(selectedElement);
    selectedElement = null;
  }
  groupedElements.forEach(el => {
    el.classList.remove('element-grouped');
    removeItemResizeHandles(el);
  });
  groupedElements.clear();
}

function getSelectedGroup() {
  // Returns all selected elements (group + primary)
  if (groupedElements.size > 0) return [...groupedElements];
  if (selectedElement) return [selectedElement];
  return [];
}

function updateDims(id) {
  const el = panels[id].el;
  const dims = el.querySelector('.dims');
  if (dims) dims.textContent = `${parseInt(el.style.width)}Ã—${parseInt(el.style.height)}`;
}

function updateInfoBar(id) {
  const el = panels[id].el;
  const x = parseInt(el.style.left), y = parseInt(el.style.top);
  const w = parseInt(el.style.width), h = parseInt(el.style.height);
  const cr = canvas.getBoundingClientRect();
  document.getElementById('infoSelected').textContent = panels[id].title;
  document.getElementById('infoPos').textContent = `${x},${y}`;
  document.getElementById('infoSize').textContent = `${w}Ã—${h} (${((w/cr.width)*100).toFixed(0)}%Ã—${((h/cr.height)*100).toFixed(0)}%)`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PRESETS / PAGES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function lastId() { return Object.keys(panels).pop(); }

function setPanelSize(id, w, h) {
  const el = panels[id].el;
  el.style.width = w + 'px';
  el.style.height = h + 'px';
  updateDims(id);
}

function clearCanvas() {
  Object.keys(panels).forEach(id => { panels[id].el.remove(); });
  panels = {};
  selectedPanelId = null;
  panelCounter = 0;
}

function loadPage(name) {
  saveUndoState();
  clearCanvas();
  const c = canvas.getBoundingClientRect();
  const pad = 16;
  const iw = c.width - pad * 2;

  if (name === 'tutor-setup') {
    // VAULT FILES â€” left column, full height
    createPanel('vault', 0, 0);
    setPanelSize(lastId(), 304, 584);

    // TOOLBAR â€” top right
    createPanel('toolbar', 304, 0);
    setPanelSize(lastId(), 512, 104);

    // RECENT SESSIONS â€” below toolbar, takes remaining right area
    createPanel('sessions', 304, 104);
    setPanelSize(lastId(), 512, 480);

    selectPanel(null);
  } else if (name === 'tutor-chat') {
    const gap = 8;
    const barH = 40;
    const contentH = c.height - pad * 2 - barH - gap;
    const chatW = Math.floor(iw * 0.7);
    const artW = iw - chatW - gap;

    createPanel('toolbar', pad, pad);
    setPanelSize(lastId(), iw, barH);
    panels[lastId()].el.querySelector('.title').textContent = 'STATUS BAR';

    createPanel('chat', pad, pad + barH + gap);
    setPanelSize(lastId(), chatW, contentH);

    createPanel('artifacts', pad + chatW + gap, pad + barH + gap);
    setPanelSize(lastId(), artW, contentH);

    selectPanel(null);
  } else {
    // Blank
  }
}

function toggleSnap() {
  snap = !snap;
  const btn = document.getElementById('snapBtn');
  btn.textContent = `SNAP: ${snap ? 'ON' : 'OFF'}`;
  btn.classList.toggle('active', snap);
}

function togglePush() {
  pushEnabled = !pushEnabled;
  const btn = document.getElementById('pushBtn');
  btn.textContent = `PUSH: ${pushEnabled ? 'ON' : 'OFF'}`;
  btn.classList.toggle('active', pushEnabled);
}

function toggleHand() {
  handMode = !handMode;
  const btn = document.getElementById('handBtn');
  btn.classList.toggle('active', handMode);
  canvas.classList.toggle('hand-mode', handMode);
}

function toggleBorders() {
  bordersVisible = !bordersVisible;
  document.body.classList.toggle('hide-borders', !bordersVisible);
  const btn = document.getElementById('borderBtn');
  btn.textContent = `BORDERS: ${bordersVisible ? 'ON' : 'OFF'}`;
  btn.classList.toggle('active', bordersVisible);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TOOLBAR TOOLS â€” H-SPLIT, V-SPLIT, BOX, SPLIT PRESETS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function addHSplit() {
  if (!selectedPanelId || !panels[selectedPanelId]) return;
  saveUndoState();
  const body = panels[selectedPanelId].el.querySelector('.panel-body');
  if (!body) return;

  // Find direct-child zones, pick the tallest to split
  const directZones = [...body.querySelectorAll(':scope > .drop-zone')];
  if (directZones.length === 0) return;

  let tallest = directZones[0];
  let maxH = tallest.getBoundingClientRect().height;
  directZones.forEach(z => {
    const h = z.getBoundingClientRect().height;
    if (h > maxH) { maxH = h; tallest = z; }
  });

  const halfH = Math.max(16, Math.floor(maxH / 2));
  tallest.style.height = halfH + 'px';
  tallest.style.flex = 'none';
  tallest.style.minHeight = '16px';
  tallest.style.overflow = 'auto';

  const div = document.createElement('div');
  div.className = 'zone-divider';

  const newZone = document.createElement('div');
  newZone.className = 'drop-zone vertical';
  newZone.style.height = halfH + 'px';
  newZone.style.flex = 'none';
  newZone.style.minHeight = '16px';
  newZone.style.overflow = 'auto';

  if (tallest.nextSibling) {
    body.insertBefore(div, tallest.nextSibling);
    body.insertBefore(newZone, div.nextSibling);
  } else {
    body.appendChild(div);
    body.appendChild(newZone);
  }
}

function addVSplit() {
  if (!selectedPanelId || !panels[selectedPanelId]) return;
  saveUndoState();
  const body = panels[selectedPanelId].el.querySelector('.panel-body');
  if (!body) return;

  let row = body.querySelector(':scope > .zone-row');

  if (row) {
    // Add another column to existing row
    const existingZones = [...row.querySelectorAll(':scope > .drop-zone')];
    const totalW = row.getBoundingClientRect().width;
    const newCount = existingZones.length + 1;
    const divCount = row.querySelectorAll(':scope > .zone-col-divider').length + 1;
    const colW = Math.floor((totalW - divCount * 6) / newCount);

    existingZones.forEach(z => {
      z.style.width = colW + 'px';
      z.style.flex = 'none';
    });

    const div = document.createElement('div');
    div.className = 'zone-col-divider';
    const newZone = document.createElement('div');
    newZone.className = 'drop-zone vertical';
    newZone.style.width = colW + 'px';
    newZone.style.flex = 'none';
    newZone.style.minWidth = '40px';
    newZone.style.overflow = 'auto';

    row.appendChild(div);
    row.appendChild(newZone);
  } else {
    // Wrap current content into a two-column row
    const children = [...body.children];
    row = document.createElement('div');
    row.className = 'zone-row';

    const leftZone = document.createElement('div');
    leftZone.className = 'drop-zone vertical';
    leftZone.style.flex = '1';
    leftZone.style.minWidth = '40px';
    leftZone.style.overflow = 'auto';
    children.forEach(c => leftZone.appendChild(c));

    const div = document.createElement('div');
    div.className = 'zone-col-divider';

    const rightZone = document.createElement('div');
    rightZone.className = 'drop-zone vertical';
    rightZone.style.flex = '1';
    rightZone.style.minWidth = '40px';
    rightZone.style.overflow = 'auto';

    row.appendChild(leftZone);
    row.appendChild(div);
    row.appendChild(rightZone);
    body.appendChild(row);

    requestAnimationFrame(() => {
      const totalW = row.getBoundingClientRect().width;
      const colW = Math.floor((totalW - 6) / 2);
      leftZone.style.width = colW + 'px';
      leftZone.style.flex = 'none';
      rightZone.style.width = colW + 'px';
      rightZone.style.flex = 'none';
    });
  }
}

function addBox() {
  if (!selectedPanelId || !panels[selectedPanelId]) return;
  saveUndoState();
  const body = panels[selectedPanelId].el.querySelector('.panel-body');
  if (!body) return;

  const zones = [...body.querySelectorAll('.drop-zone')];
  const targetZone = zones.length > 0 ? zones[0] : body;

  const box = document.createElement('div');
  box.className = 'inner-box drop-zone vertical';
  box.style.minHeight = '40px';
  box.innerHTML = '<span class="box-label">BOX</span>';
  targetZone.appendChild(box);
}

function splitPanel(type) {
  if (!selectedPanelId || !panels[selectedPanelId]) return;
  saveUndoState();
  const el = panels[selectedPanelId].el;
  const body = el.querySelector('.panel-body');
  if (!body) return;

  const existingItems = [...body.querySelectorAll('.drag-item')];
  body.innerHTML = '';

  const makeZone = (dir = 'v') => {
    const z = document.createElement('div');
    z.className = 'drop-zone' + (dir === 'v' ? ' vertical' : '');
    z.style.minHeight = '16px';
    z.style.minWidth = '40px';
    z.style.overflow = 'auto';
    return z;
  };

  if (type === '2-col') {
    const row = document.createElement('div');
    row.className = 'zone-row';
    row.style.flex = '1';
    const left = makeZone(); left.style.flex = '1';
    const div = document.createElement('div'); div.className = 'zone-col-divider';
    const right = makeZone(); right.style.flex = '1';
    row.appendChild(left); row.appendChild(div); row.appendChild(right);
    body.appendChild(row);
    existingItems.forEach(item => left.appendChild(item));
    requestAnimationFrame(() => {
      const w = row.getBoundingClientRect().width;
      const cw = Math.floor((w - 6) / 2);
      left.style.width = cw + 'px'; left.style.flex = 'none';
      right.style.width = cw + 'px'; right.style.flex = 'none';
    });

  } else if (type === '3-col') {
    const row = document.createElement('div');
    row.className = 'zone-row';
    row.style.flex = '1';
    const z1 = makeZone(); z1.style.flex = '1';
    const d1 = document.createElement('div'); d1.className = 'zone-col-divider';
    const z2 = makeZone(); z2.style.flex = '1';
    const d2 = document.createElement('div'); d2.className = 'zone-col-divider';
    const z3 = makeZone(); z3.style.flex = '1';
    row.appendChild(z1); row.appendChild(d1); row.appendChild(z2); row.appendChild(d2); row.appendChild(z3);
    body.appendChild(row);
    existingItems.forEach(item => z1.appendChild(item));
    requestAnimationFrame(() => {
      const w = row.getBoundingClientRect().width;
      const cw = Math.floor((w - 12) / 3);
      [z1,z2,z3].forEach(z => { z.style.width = cw + 'px'; z.style.flex = 'none'; });
    });

  } else if (type === '2-row') {
    const bh = body.getBoundingClientRect().height;
    const zh = Math.floor((bh - 6) / 2);
    const z1 = makeZone(); z1.style.height = zh + 'px'; z1.style.flex = 'none';
    const div = document.createElement('div'); div.className = 'zone-divider';
    const z2 = makeZone(); z2.style.height = zh + 'px'; z2.style.flex = 'none';
    body.appendChild(z1); body.appendChild(div); body.appendChild(z2);
    existingItems.forEach(item => z1.appendChild(item));

  } else if (type === 'grid') {
    const bh = body.getBoundingClientRect().height;
    const rh = Math.floor((bh - 6) / 2);

    const makeRow = () => {
      const row = document.createElement('div');
      row.className = 'zone-row';
      row.style.height = rh + 'px';
      row.style.flex = 'none';
      const l = makeZone(); l.style.flex = '1';
      const d = document.createElement('div'); d.className = 'zone-col-divider';
      const r = makeZone(); r.style.flex = '1';
      row.appendChild(l); row.appendChild(d); row.appendChild(r);
      return { row, left: l, right: r };
    };

    const top = makeRow();
    const rowDiv = document.createElement('div'); rowDiv.className = 'zone-divider';
    const bot = makeRow();

    body.appendChild(top.row);
    body.appendChild(rowDiv);
    body.appendChild(bot.row);

    existingItems.forEach(item => top.left.appendChild(item));

    requestAnimationFrame(() => {
      [top.row, bot.row].forEach(row => {
        const w = row.getBoundingClientRect().width;
        const cw = Math.floor((w - 6) / 2);
        [...row.querySelectorAll(':scope > .drop-zone')].forEach(z => {
          z.style.width = cw + 'px'; z.style.flex = 'none';
        });
      });
    });
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ALIGN â€” panels globally OR inner zones when a panel is selected
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function alignPanels(direction) {
  saveUndoState();
  // --- Inner mode: align zone contents inside selected panel ---
  if (selectedPanelId && panels[selectedPanelId]) {
    const body = panels[selectedPanelId].el.querySelector('.panel-body');
    if (!body) return;
    const zones = [...body.querySelectorAll('.drop-zone')];
    const map = { left: 'flex-start', center: 'center', right: 'flex-end' };
    zones.forEach(z => {
      const isVert = window.getComputedStyle(z).flexDirection === 'column';
      if (isVert) {
        z.style.alignItems = map[direction] || 'stretch';
      } else {
        z.style.justifyContent = map[direction] || 'flex-start';
      }
    });
    return;
  }

  // --- Global mode: move all panels ---
  const cr = canvas.getBoundingClientRect();
  const pad = 16;
  const ids = Object.keys(panels);
  if (ids.length === 0) return;

  ids.forEach(id => {
    const el = panels[id].el;
    const w = parseInt(el.style.width) || 120;

    if (direction === 'left') {
      el.style.left = pad + 'px';
    } else if (direction === 'center') {
      el.style.left = snapV(Math.floor((cr.width - w) / 2)) + 'px';
    } else if (direction === 'right') {
      el.style.left = snapV(cr.width - w - pad) + 'px';
    }

    clampToCanvas(el);
    updateDims(id);
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AUTO-SPACE â€” panels globally OR inner zones when selected
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function autoSpace() {
  saveUndoState();
  // --- Inner mode: equalize zone heights inside selected panel ---
  if (selectedPanelId && panels[selectedPanelId]) {
    const body = panels[selectedPanelId].el.querySelector('.panel-body');
    if (!body) return;

    // Find direct-child zones (may be inside a zone-row too)
    const directZones = [...body.querySelectorAll(':scope > .drop-zone')];
    const rows = [...body.querySelectorAll(':scope > .zone-row')];
    const dividers = [...body.querySelectorAll(':scope > .zone-divider')];
    const bodyH = body.getBoundingClientRect().height;

    if (directZones.length > 0) {
      const divH = dividers.length * 6;
      const rowH = rows.reduce((s, r) => s + r.getBoundingClientRect().height, 0);
      const available = bodyH - divH - rowH;
      const zoneH = Math.max(16, Math.floor(available / directZones.length));
      directZones.forEach(z => {
        z.style.height = zoneH + 'px';
        z.style.flex = 'none';
      });
    }

    // Also equalize columns inside any zone-row
    rows.forEach(row => {
      const cols = [...row.querySelectorAll(':scope > .drop-zone')];
      const colDivs = row.querySelectorAll(':scope > .zone-col-divider').length;
      const rowW = row.getBoundingClientRect().width;
      const colW = Math.max(40, Math.floor((rowW - colDivs * 6) / cols.length));
      cols.forEach(c => {
        c.style.width = colW + 'px';
        c.style.flex = 'none';
      });
    });
    return;
  }

  // --- Global mode: even vertical spacing ---
  const cr = canvas.getBoundingClientRect();
  const ids = Object.keys(panels);
  if (ids.length === 0) return;

  const sorted = [...ids].sort((a, b) =>
    (parseInt(panels[a].el.style.top) || 0) - (parseInt(panels[b].el.style.top) || 0)
  );

  const pad = 16;
  const totalH = sorted.reduce((s, id) => s + (parseInt(panels[id].el.style.height) || 48), 0);
  const available = cr.height - pad * 2;
  const gapCount = sorted.length - 1;
  const gap = gapCount > 0 ? Math.max(0, snapV((available - totalH) / gapCount)) : 0;

  let y = pad;
  sorted.forEach(id => {
    panels[id].el.style.top = snapV(y) + 'px';
    clampToCanvas(panels[id].el);
    y += (parseInt(panels[id].el.style.height) || 48) + gap;
    updateDims(id);
  });
}

function adjustGap(delta) {
  saveUndoState();
  // --- Inner mode: grow/shrink dividers inside selected panel ---
  if (selectedPanelId && panels[selectedPanelId]) {
    const body = panels[selectedPanelId].el.querySelector('.panel-body');
    if (!body) return;

    // Row dividers (horizontal gaps between zones)
    const rowDivs = [...body.querySelectorAll(':scope > .zone-divider')];
    rowDivs.forEach(d => {
      const cur = parseInt(d.style.height) || 6;
      d.style.height = Math.max(2, cur + delta) + 'px';
    });

    // Col dividers (vertical gaps in zone-rows)
    const colDivs = [...body.querySelectorAll('.zone-col-divider')];
    colDivs.forEach(d => {
      const cur = parseInt(d.style.width) || 6;
      d.style.width = Math.max(2, cur + delta) + 'px';
    });

    // Recalculate zone sizes to fit
    const directZones = [...body.querySelectorAll(':scope > .drop-zone')];
    if (directZones.length > 0) {
      const bodyH = body.getBoundingClientRect().height;
      const divH = rowDivs.reduce((s, d) => s + (parseInt(d.style.height) || 6), 0);
      const rows = [...body.querySelectorAll(':scope > .zone-row')];
      const rowH = rows.reduce((s, r) => s + r.getBoundingClientRect().height, 0);
      const available = bodyH - divH - rowH;
      const zoneH = Math.max(16, Math.floor(available / directZones.length));
      directZones.forEach(z => {
        z.style.height = zoneH + 'px';
        z.style.flex = 'none';
      });
    }

    body.querySelectorAll('.zone-row').forEach(row => {
      const cols = [...row.querySelectorAll(':scope > .drop-zone')];
      const cDivs = row.querySelectorAll(':scope > .zone-col-divider');
      const totalDivW = [...cDivs].reduce((s, d) => s + (parseInt(d.style.width) || 6), 0);
      const rowW = row.getBoundingClientRect().width;
      const colW = Math.max(40, Math.floor((rowW - totalDivW) / cols.length));
      cols.forEach(c => {
        c.style.width = colW + 'px';
        c.style.flex = 'none';
      });
    });
    return;
  }

  // --- Global mode: shift panels apart/together ---
  const ids = Object.keys(panels);
  if (ids.length < 2) return;

  const sorted = [...ids].sort((a, b) =>
    (parseInt(panels[a].el.style.top) || 0) - (parseInt(panels[b].el.style.top) || 0)
  );

  for (let i = 1; i < sorted.length; i++) {
    const el = panels[sorted[i]].el;
    const curY = parseInt(el.style.top) || 0;
    el.style.top = snapV(Math.max(0, curY + delta * i)) + 'px';
    clampToCanvas(el);
    updateDims(sorted[i]);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXPLODE â€” turn items inside a panel into individual panels
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function explodePanel() {
  if (!selectedPanelId || !panels[selectedPanelId]) return;
  saveUndoState();
  const srcPanel = panels[selectedPanelId].el;
  const srcRect = getPanelRect(srcPanel);
  const zones = [...srcPanel.querySelectorAll('.drop-zone')];

  // Collect all zones with their items
  const pieces = [];
  zones.forEach((zone, zi) => {
    const items = [...zone.querySelectorAll(':scope > .drag-item')];
    if (items.length === 0) return;
    // Each zone becomes its own panel
    pieces.push({ items, zoneIndex: zi });
  });

  if (pieces.length === 0) return;

  // Calculate layout: stack new panels below the original
  const gap = 8;
  let nextY = srcRect.y;
  const panelW = Math.max(200, srcRect.w);
  const panelH = 80;

  // Remove the original panel
  const origTitle = panels[selectedPanelId].title;
  removePanel(selectedPanelId);

  // Create a new card panel for each zone's contents
  pieces.forEach((piece, i) => {
    const pid = createPanel('card', srcRect.x, nextY);
    setPanelSize(pid, panelW, panelH);
    panels[pid].title = `${origTitle} #${i + 1}`;
    const titleEl = panels[pid].el.querySelector('.title');
    if (titleEl) titleEl.textContent = panels[pid].title;

    const zone = panels[pid].el.querySelector('.drop-zone');
    if (zone) {
      piece.items.forEach(item => zone.appendChild(item));
    }

    nextY += panelH + gap;
  });

  // Resolve any collisions from new panels
  const allIds = Object.keys(panels);
  if (allIds.length > 0) resolveCollisions(allIds[allIds.length - 1]);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PROMPT GENERATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updatePrompt() {
  const c = canvas.getBoundingClientRect();
  const parts = [];
  parts.push('Update the page layout with these specifications:\n');

  const sorted = Object.entries(panels).sort((a,b) => {
    const ay = parseInt(a[1].el.style.top), by = parseInt(b[1].el.style.top);
    return ay - by || parseInt(a[1].el.style.left) - parseInt(b[1].el.style.left);
  });

  sorted.forEach(([id, p]) => {
    const el = p.el;
    const x = parseInt(el.style.left), y = parseInt(el.style.top);
    const w = parseInt(el.style.width), h = parseInt(el.style.height);
    const pW = ((w/c.width)*100).toFixed(0);
    const pH = ((h/c.height)*100).toFixed(0);

    parts.push(`${p.title}:`);
    parts.push(`  Position: (${x}, ${y})  Size: ${w}Ã—${h}px (${pW}%Ã—${pH}%)`);

    // List zone contents
    const zones = el.querySelectorAll('.drop-zone');
    zones.forEach(zone => {
      const items = [...zone.querySelectorAll(':scope > .drag-item')];
      if (items.length > 0) {
        const names = items.map(i => i.textContent.trim().replace(/\s+/g, ' ')).filter(Boolean);
        if (names.length) parts.push(`  Contents: ${names.join(' | ')}`);
      }
    });
    parts.push('');
  });

  document.getElementById('promptText').textContent = parts.join('\n');
}

function copyPrompt() {
  updatePrompt();
  const text = document.getElementById('promptText').textContent;
  navigator.clipboard.writeText(text).then(() => {
    const btn = document.querySelector('.tb-copy');
    const orig = btn.textContent;
    btn.textContent = 'COPIED!';
    btn.style.background = '#4ade80';
    setTimeout(() => { btn.textContent = orig; btn.style.background = ''; }, 1200);
  });
  document.getElementById('promptBar').classList.add('visible');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYBOARD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.addEventListener('keydown', (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); return; }
  if (e.key === 'Delete' || e.key === 'Backspace') {
    if (selectedPanelId && !e.target.closest('input,textarea')) {
      removePanel(selectedPanelId);
    }
  }
  if (e.key === 'Escape') selectPanel(null);
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function init() {
  renderPalette();

  const updateCanvasInfo = () => {
    const r = canvas.getBoundingClientRect();
    document.getElementById('infoCanvas').textContent = `${Math.round(r.width)}Ã—${Math.round(r.height)}`;
  };
  updateCanvasInfo();
  window.addEventListener('resize', updateCanvasInfo);

  // Load tutor setup by default
  loadPage('tutor-setup');
}

init();
</script>
</body>
</html>
